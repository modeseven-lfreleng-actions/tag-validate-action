---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

# Action test/validation workflow
name: "Test GitHub Action ðŸ§ª"

# yamllint disable-line rule:truthy
on:
  workflow_dispatch:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

concurrency:
  group: "${{ github.workflow }}-${{ github.ref }}"
  cancel-in-progress: true

permissions: {}

jobs:
  ### Test String Validation (No Signature Check) ###
  test-string-validation:
    name: "Test String Validation"
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: "Test SemVer string - valid"
        uses: ./
        id: semver-valid
        with:
          tag_string: "1.2.3"
          require_type: semver

      - name: "Verify SemVer output"
        shell: bash
        run: |
          if [ "${{ steps.semver-valid.outputs.tag_type }}" != "semver" ]; then
            echo "Error: Expected tag_type=semver, got \
              ${{ steps.semver-valid.outputs.tag_type }}"
            exit 1
          fi
          if [ "${{ steps.semver-valid.outputs.version_prefix }}" \
            != "false" ]; then
            echo "Error: Expected version_prefix=false"
            exit 1
          fi
          echo "âœ“ SemVer string validation passed"

      - name: "Test SemVer string with v prefix"
        uses: ./
        id: semver-prefix
        with:
          tag_string: "v2.3.1-beta.1"
          require_type: semver

      - name: "Verify prefix detection"
        shell: bash
        run: |
          if [ "${{ steps.semver-prefix.outputs.version_prefix }}" \
            != "true" ]; then
            echo "Error: Expected version_prefix=true"
            exit 1
          fi
          if [ "${{ steps.semver-prefix.outputs.development_tag }}" \
            != "true" ]; then
            echo "Error: Expected development_tag=true (beta)"
            exit 1
          fi
          echo "âœ“ Prefix and development tag detected"

      - name: "Test CalVer string - valid"
        uses: ./
        id: calver-valid
        with:
          tag_string: "2025.01.15"
          require_type: calver

      - name: "Verify CalVer output"
        shell: bash
        run: |
          if [ "${{ steps.calver-valid.outputs.tag_type }}" != "calver" ]; then
            echo "Error: Expected tag_type=calver, got \
              ${{ steps.calver-valid.outputs.tag_type }}"
            exit 1
          fi
          echo "âœ“ CalVer string validation passed"

      - name: "Test CalVer with development identifier"
        uses: ./
        id: calver-dev
        with:
          tag_string: "v2025.1.0-alpha.1"

      - name: "Verify development tag detection"
        shell: bash
        run: |
          if [ "${{ steps.calver-dev.outputs.development_tag }}" \
            != "true" ]; then
            echo "Error: Expected development_tag=true"
            exit 1
          fi
          echo "âœ“ Development tag detected in CalVer"

      - name: "Test type mismatch - should fail"
        uses: ./
        id: type-mismatch
        continue-on-error: true
        with:
          tag_string: "1.2.3"
          require_type: calver

      - name: "Verify type mismatch failed"
        if: steps.type-mismatch.outcome == 'success'
        shell: bash
        run: |
          echo "Error: Type mismatch should have failed"
          exit 1

      - name: "Test unknown format with require_type=none"
        uses: ./
        id: unknown-format
        with:
          tag_string: "random-tag-name"
          require_type: none

      - name: "Verify unknown format accepted"
        shell: bash
        run: |
          if [ "${{ steps.unknown-format.outputs.tag_type }}" \
            != "other" ]; then
            echo "Error: Expected tag_type=other"
            exit 1
          fi
          echo "âœ“ Other format accepted with require_type=none"

  ### Test Local Tag Validation (Tag Push Event Simulation) ###
  test-local-tags:
    name: "Test Local Tag Validation"
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0

      - name: "Create test tags locally"
        shell: bash
        run: |
          git config user.name "Test User"
          git config user.email "test@example.com"

          # Create unsigned tag
          git tag -a test-semver-1.0.0 -m "Test SemVer tag"
          git tag -a test-calver-2025.01.0 -m "Test CalVer tag"
          git tag -a test-dev-1.0.0-beta -m "Test dev tag"

          git tag -l

      - name: "Test validation with explicit tag_string"
        uses: ./
        id: explicit-tag
        with:
          tag_string: "test-semver-1.0.0"
          require_type: none

      - name: "Test missing tag with permit_missing=true"
        uses: ./
        id: missing-permitted
        with:
          permit_missing: true

      - name: "Verify permit_missing worked"
        shell: bash
        run: |
          if [ "${{ steps.missing-permitted.outputs.valid }}" != "true" ]; then
            echo "Error: Should succeed with permit_missing=true"
            exit 1
          fi
          echo "âœ“ permit_missing=true works correctly"

      - name: "Test missing tag with permit_missing=false - should fail"
        uses: ./
        id: missing-fail
        continue-on-error: true
        with:
          permit_missing: false

      - name: "Verify missing tag failed"
        if: steps.missing-fail.outcome == 'success'
        shell: bash
        run: |
          echo "Error: Should have failed without permit_missing"
          exit 1

  ### Test Remote Tag Validation ###
  test-remote-tags:
    name: "Test Remote Tag Validation"
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: "Test remote tag - semantic versioning"
        uses: ./
        id: remote-semver
        with:
          tag_location: >-
            lfreleng-actions/test-tags-semantic/v0.1.2-unsigned
          require_type: semver
          permit_missing: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Verify remote tag validation"
        shell: bash
        run: |
          echo "Tag Name: ${{ steps.remote-semver.outputs.tag_name }}"
          echo "Tag Type: ${{ steps.remote-semver.outputs.tag_type }}"
          echo "Signing Type: ${{ steps.remote-semver.outputs.signing_type }}"

      - name: "Test remote tag - calendar versioning"
        uses: ./
        id: remote-calver
        with:
          tag_location: >-
            lfreleng-actions/test-tags-calver/2025.1.2-unsigned
          require_type: calver
          permit_missing: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Test invalid tag_location format - should fail"
        uses: ./
        id: invalid-location
        continue-on-error: true
        with:
          tag_location: "invalid-format"
          permit_missing: false

      - name: "Verify invalid format failed"
        if: steps.invalid-location.outcome == 'success'
        shell: bash
        run: |
          echo "Error: Invalid tag_location should have failed"
          exit 1

      - name: "Test non-existent remote tag with permit_missing=true"
        uses: ./
        id: missing-remote
        with:
          tag_location: >-
            lfreleng-actions/test-tags-semantic/v999.999.999
          permit_missing: true

      - name: "Test tag with v prefix stripping"
        uses: ./
        id: prefix-strip
        with:
          tag_location: >-
            lfreleng-actions/test-tags-semantic/v0.1.0
          permit_missing: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Test with token for rate limit increase"
        uses: ./
        id: with-token
        with:
          tag_location: >-
            lfreleng-actions/test-tags-semantic/v0.1.0
          require_type: semver
          permit_missing: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: "Verify token usage succeeded"
        shell: bash
        run: |
          if [ "${{ steps.with-token.outputs.valid }}" != "true" ]; then
            echo "Error: Token-authenticated request should have succeeded"
            exit 1
          fi
          echo "âœ“ Token-authenticated request succeeded"

  ### Test Signature Validation ###
  test-signatures:
    name: "Test Signature Detection"
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 5

    steps:
      - name: "Checkout test-tags-semantic repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          repository: lfreleng-actions/test-tags-semantic
          fetch-depth: 0
          path: test-repo-semver

      - name: "Checkout test-tags-calver repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          repository: lfreleng-actions/test-tags-calver
          fetch-depth: 0
          path: test-repo-calver

      - name: "Checkout action repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          path: action-code

      - name: "Import GPG test key for signature verification"
        # yamllint disable-line rule:line-length
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec
        # Allow failure when GPG_PRIVATE_KEY secret is not set
        # (tests will then expect gpg-unverifiable instead of gpg)
        continue-on-error: true
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          trust_level: ultimate

      - name: "Set GPG key availability flag"
        shell: bash
        run: |
          if gpg --list-secret-keys "test@tag-validate-action.local" \
            &>/dev/null; then
            echo "GPG_KEY_AVAILABLE=true" >> "$GITHUB_ENV"
            echo "âœ“ GPG test key available"
          else
            echo "GPG_KEY_AVAILABLE=false" >> "$GITHUB_ENV"
            echo "No GPG key available - tests expect gpg-unverifiable"
          fi

      - name: "Test string mode (always unsigned)"
        uses: ./action-code
        id: string-mode
        with:
          tag_string: "v0.1.2-unsigned"

      - name: "Verify string mode reports unsigned"
        shell: bash
        run: |
          echo "Signing Type: ${{ steps.string-mode.outputs.signing_type }}"
          if [ "${{ steps.string-mode.outputs.signing_type }}" \
            != "unsigned" ]; then
            echo "Error: Expected signing_type=unsigned in string mode"
            exit 1
          fi
          echo "âœ“ String mode correctly reports unsigned"

      - name: "Test GPG-signed tag detection (semver)"
        uses: ./action-code
        id: gpg-semver
        with:
          tag_location: test-repo-semver/v0.1.4-gpg-test

      - name: "Verify GPG signature detection (semver)"
        shell: bash
        run: |
          echo "Signing Type: ${{ steps.gpg-semver.outputs.signing_type }}"
          echo "GPG Key Available: ${{ env.GPG_KEY_AVAILABLE }}"

          # Expected result depends on whether GPG key is available
          if [ "${{ env.GPG_KEY_AVAILABLE }}" = "true" ]; then
            # With key: should verify as 'gpg'
            if [ "${{ steps.gpg-semver.outputs.signing_type }}" != "gpg" ]; then
              echo "Error: Expected signing_type=gpg (key available)"
              exit 1
            fi
            echo "âœ“ GPG signature verified correctly"
          else
            # Without key: should be 'gpg-unverifiable'
            if [ "${{ steps.gpg-semver.outputs.signing_type }}" \
              != "gpg-unverifiable" ]; then
              echo "Error: Expected signing_type=gpg-unverifiable"
              exit 1
            fi
            echo "âœ“ GPG signature detected but unverifiable"
          fi

      - name: "Test SSH-signed tag detection (semver)"
        uses: ./action-code
        id: ssh-semver
        with:
          tag_location: test-repo-semver/v0.1.3-ssh-signed

      - name: "Verify SSH signature detection (semver)"
        shell: bash
        run: |
          echo "Signing Type: ${{ steps.ssh-semver.outputs.signing_type }}"
          if [ "${{ steps.ssh-semver.outputs.signing_type }}" \
            != "ssh" ]; then
            echo "Error: Expected signing_type=ssh for v0.1.3-ssh-signed"
            exit 1
          fi
          echo "âœ“ SSH signature detected correctly"

      - name: "Test unsigned tag detection (semver)"
        uses: ./action-code
        id: unsigned-semver
        with:
          tag_location: test-repo-semver/v0.1.2-unsigned

      - name: "Verify unsigned tag detection (semver)"
        shell: bash
        run: |
          echo \
            "Signing Type: ${{ steps.unsigned-semver.outputs.signing_type }}"
          if [ "${{ steps.unsigned-semver.outputs.signing_type }}" \
            != "unsigned" ]; then
            echo "Error: Expected signing_type=unsigned for v0.1.2-unsigned"
            exit 1
          fi
          echo "âœ“ Unsigned tag detected correctly"

      - name: "Test GPG-signed tag detection (calver)"
        uses: ./action-code
        id: gpg-calver
        with:
          tag_location: test-repo-calver/2025.1.4-gpg-test

      - name: "Verify GPG signature detection (calver)"
        shell: bash
        run: |
          echo "Signing Type: ${{ steps.gpg-calver.outputs.signing_type }}"
          echo "GPG Key Available: ${{ env.GPG_KEY_AVAILABLE }}"

          # Expected result depends on whether GPG key is available
          if [ "${{ env.GPG_KEY_AVAILABLE }}" = "true" ]; then
            # With key: should verify as 'gpg'
            if [ "${{ steps.gpg-calver.outputs.signing_type }}" != "gpg" ]; then
              echo "Error: Expected signing_type=gpg (key available)"
              exit 1
            fi
            echo "âœ“ GPG signature verified correctly"
          else
            # Without key: should be 'gpg-unverifiable'
            if [ "${{ steps.gpg-calver.outputs.signing_type }}" \
              != "gpg-unverifiable" ]; then
              echo "Error: Expected signing_type=gpg-unverifiable"
              exit 1
            fi
            echo "âœ“ GPG signature detected but unverifiable"
          fi

      - name: "Test SSH-signed tag detection (calver)"
        uses: ./action-code
        id: ssh-calver
        with:
          tag_location: test-repo-calver/2025.1.3-ssh-signed

      - name: "Verify SSH signature detection (calver)"
        shell: bash
        run: |
          echo "Signing Type: ${{ steps.ssh-calver.outputs.signing_type }}"
          if [ "${{ steps.ssh-calver.outputs.signing_type }}" \
            != "ssh" ]; then
            echo "Error: Expected signing_type=ssh for 2025.1.3-ssh-signed"
            exit 1
          fi
          echo "âœ“ SSH signature detected correctly (calver)"

      - name: "Test unsigned tag detection (calver)"
        uses: ./action-code
        id: unsigned-calver
        with:
          tag_location: test-repo-calver/2025.1.2-unsigned

      - name: "Verify unsigned tag detection (calver)"
        shell: bash
        run: |
          echo \
            "Signing Type: ${{ steps.unsigned-calver.outputs.signing_type }}"
          if [ "${{ steps.unsigned-calver.outputs.signing_type }}" \
            != "unsigned" ]; then
            echo "Error: Expected signing_type=unsigned for 2025.1.2-unsigned"
            exit 1
          fi
          echo "âœ“ Unsigned tag detected correctly (calver)"

      - name: "Test GPG-unverifiable tag detection (semver)"
        uses: ./action-code
        id: gpg-unverifiable-semver
        with:
          tag_location: test-repo-semver/v0.1.6-gpg-unknown

      - name: "Verify GPG-unverifiable signature detection (semver)"
        shell: bash
        # yamllint disable rule:line-length
        run: |
          echo "Signing Type: ${{ steps.gpg-unverifiable-semver.outputs.signing_type }}"
          if [ "${{ steps.gpg-unverifiable-semver.outputs.signing_type }}" \
            != "gpg-unverifiable" ]; then
            echo "Error: Expected signing_type=gpg-unverifiable for" \
                 "v0.1.6-gpg-unknown (signed with unknown key)"
            exit 1
          fi
          echo "âœ“ GPG-unverifiable signature detected correctly (semver)"
        # yamllint enable rule:line-length

      - name: "Test GPG-unverifiable tag detection (calver)"
        uses: ./action-code
        id: gpg-unverifiable-calver
        with:
          tag_location: test-repo-calver/2025.1.6-gpg-unknown

      - name: "Verify GPG-unverifiable signature detection (calver)"
        shell: bash
        # yamllint disable rule:line-length
        run: |
          echo "Signing Type: ${{ steps.gpg-unverifiable-calver.outputs.signing_type }}"
          if [ "${{ steps.gpg-unverifiable-calver.outputs.signing_type }}" \
            != "gpg-unverifiable" ]; then
            echo "Error: Expected signing_type=gpg-unverifiable for" \
                 "2025.1.6-gpg-unknown (signed with unknown key)"
            exit 1
          fi
          echo "âœ“ GPG-unverifiable signature detected correctly (calver)"
        # yamllint enable rule:line-length

      - name: "Test require_signed=true with GPG-unverifiable tag (should fail)"
        uses: ./action-code
        id: require-signed-unverifiable
        continue-on-error: true
        with:
          tag_location: test-repo-semver/v0.1.6-gpg-unknown
          require_signed: gpg

      - name: "Verify require_signed=true rejects GPG-unverifiable tag"
        shell: bash
        run: |
          if [ "${{ steps.require-signed-unverifiable.outcome }}" \
            == "success" ]; then
            echo "Error: require_signed=true should reject" \
                 "gpg-unverifiable signatures"
            exit 1
          fi
          echo "âœ“ require_signed=true correctly rejected gpg-unverifiable tag"

      - name: "Test require_signed=true with GPG tag"
        uses: ./action-code
        id: require-signed-gpg
        continue-on-error: true
        with:
          tag_location: test-repo-semver/v0.1.4-gpg-test
          require_signed: gpg

      - name: "Verify require_signed=true with GPG tag"
        shell: bash
        run: |
          # SECURITY: require_signed=true now rejects gpg-unverifiable
          # This test passes only if GPG key is available (signature verifiable)
          if [ "${{ env.GPG_KEY_AVAILABLE }}" = "true" ]; then
            # With key: signature is verifiable, should pass
            if [ "${{ steps.require-signed-gpg.outcome }}" \
              != "success" ]; then
              echo "Error: require_signed=true should pass with" \
                   "verifiable GPG signature"
              exit 1
            fi
            echo "âœ“ require_signed=true accepted verifiable signature"
          else
            # Without key: signature is unverifiable, should fail
            if [ "${{ steps.require-signed-gpg.outcome }}" \
              != "failure" ]; then
              echo "Error: require_signed=true should reject" \
                   "unverifiable GPG signature"
              exit 1
            fi
            echo "âœ“ require_signed=true rejected unverifiable signature"
          fi

      - name: "Test require_signed=true with SSH tag (should pass)"
        uses: ./action-code
        id: require-signed-ssh
        with:
          tag_location: test-repo-semver/v0.1.3-ssh-signed
          require_signed: ssh

      - name: "Test require_signed=true with unsigned tag (should fail)"
        uses: ./action-code
        id: require-signed-fail
        continue-on-error: true
        with:
          tag_location: test-repo-semver/v0.1.2-unsigned
          require_signed: gpg

      - name: "Verify require_signed=true rejected unsigned tag"
        shell: bash
        run: |
          if [ "${{ steps.require-signed-fail.outcome }}" == "success" ]; then
            echo "Error: require_signed=true should reject unsigned tags"
            exit 1
          fi
          echo "âœ“ require_signed=true correctly rejected unsigned tag"

      - name: "Test require_signed=false with unsigned tag (should pass)"
        uses: ./action-code
        id: require-unsigned
        with:
          tag_location: test-repo-semver/v0.1.2-unsigned
          require_signed: unsigned

      - name: "Test no signature requirement with any tag (should pass)"
        uses: ./action-code
        id: no-requirement-any
        with:
          tag_location: test-repo-semver/v0.1.2-unsigned

  ### Test Local SSH-Signed Tags ###
  test-local-ssh-tags:
    name: "Test Local SSH-Signed Tags"
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 5
    steps:
      - name: "Checkout repository with all tags"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0

      - name: "Setup SSH allowed signers file"
        shell: bash
        run: |
          echo "Setting up SSH allowed signers file"
          # Use the committed .allowed-signers file from the repository
          if [ -f .allowed-signers ]; then
            git config gpg.ssh.allowedSignersFile .allowed-signers
            echo "âœ“ SSH allowed signers file configured"
            cat .allowed-signers
          else
            echo "Warning: .allowed-signers file not found"
            ls -la
          fi

      - name: "Verify SSH signature on v0.1.0"
        shell: bash
        run: |
          echo "Verifying v0.1.0 SSH signature with Git"
          if git verify-tag v0.1.0; then
            echo "âœ“ v0.1.0 SSH signature verified"
          else
            echo "Warning: SSH signature verification failed, continuing test"
          fi

      - name: "Verify SSH signature on v0.1.1"
        shell: bash
        run: |
          echo "Verifying v0.1.1 SSH signature with Git"
          if git verify-tag v0.1.1; then
            echo "âœ“ v0.1.1 SSH signature verified"
          else
            echo "Warning: SSH signature verification failed, continuing test"
          fi

      - name: "Install Python package"
        shell: bash
        run: |
          pip install -e .

      - name: "Test v0.1.0 with Python CLI (SSH-signed)"
        shell: bash
        run: |
          echo "Testing v0.1.0 with Python CLI"
          tag-validate verify v0.1.0 --require-type semver \
            --require-signed ssh --json > result.json
          cat result.json

          # Check success
          if [ "$(jq -r '.success' result.json)" != "true" ]; then
            echo "Error: Validation failed"
            jq '.' result.json
            exit 1
          fi

          # Check version type
          if [ "$(jq -r '.version_type' result.json)" != "semver" ]; then
            echo "Error: Expected version_type=semver"
            exit 1
          fi

          # Check signature type
          if [ "$(jq -r '.signature_type' result.json)" != "ssh" ]; then
            echo "Error: Expected signature_type=ssh"
            exit 1
          fi

          # Check signature verified
          if [ "$(jq -r '.signature_verified' result.json)" != "true" ]; then
            echo "Error: Expected signature_verified=true"
            exit 1
          fi

          echo "âœ“ v0.1.0 validated correctly as SSH-signed SemVer"

      - name: "Test v0.1.1 with Python CLI (SSH-signed)"
        shell: bash
        run: |
          echo "Testing v0.1.1 with Python CLI"
          tag-validate verify v0.1.1 --require-type semver \
            --require-signed ssh --json > result.json
          cat result.json

          # Check success
          if [ "$(jq -r '.success' result.json)" != "true" ]; then
            echo "Error: Validation failed"
            jq '.' result.json
            exit 1
          fi

          # Check version type
          if [ "$(jq -r '.version_type' result.json)" != "semver" ]; then
            echo "Error: Expected version_type=semver"
            exit 1
          fi

          # Check signature type
          if [ "$(jq -r '.signature_type' result.json)" != "ssh" ]; then
            echo "Error: Expected signature_type=ssh"
            exit 1
          fi

          # Check signature verified
          if [ "$(jq -r '.signature_verified' result.json)" != "true" ]; then
            echo "Error: Expected signature_verified=true"
            exit 1
          fi

          echo "âœ“ v0.1.1 validated correctly as SSH-signed SemVer"

  ### Test Signature Requirements ###
  test-signature-requirements:
    name: "Test Signature Requirements"
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0

      - name: "Create unsigned tag"
        shell: bash
        run: |
          git config user.name "Test User"
          git config user.email "test@example.com"
          git tag -a unsigned-test-1.0.0 -m "Unsigned test tag"

      - name: "Test no signature requirement with any string (should pass)"
        uses: ./
        id: no-requirement
        with:
          tag_string: "unsigned-test-1.0.0"

      - name: "Test require_signed=unsigned with unsigned tag (should pass)"
        uses: ./
        id: unsigned-ok
        with:
          tag_string: "1.0.0"
          require_signed: unsigned

      - name: "Test case insensitivity"
        uses: ./
        id: case-test
        with:
          tag_string: "1.0.0"
          require_type: SEMVER
          require_signed: UNSIGNED


      - name: "Verify case insensitivity"
        shell: bash
        run: |
          if [ "${{ steps.case-test.outputs.tag_type }}" != "semver" ]; then
            echo "Error: Case insensitivity failed for require_type"
            exit 1
          fi
          if [ "${{ steps.case-test.outputs.signing_type }}" != "unsigned" ]
          then
            echo "Error: Case insensitivity failed for require_signed"
            exit 1
          fi
          echo "âœ“ Case insensitive options work correctly"

  ### Test Development Tag Detection ###
  test-development-tags:
    name: "Test Development Tag Detection"
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: "Test alpha tag"
        uses: ./
        id: alpha
        with:
          tag_string: "1.0.0-alpha.1"

      - name: "Verify alpha detected"
        shell: bash
        run: |
          if [ "${{ steps.alpha.outputs.development_tag }}" != "true" ]; then
            echo "Error: alpha not detected as development"
            exit 1
          fi

      - name: "Test beta tag"
        uses: ./
        id: beta
        with:
          tag_string: "v2.0.0-beta"

      - name: "Test rc tag"
        uses: ./
        id: rc
        with:
          tag_string: "1.0.0-rc.1"

      - name: "Test dev tag"
        uses: ./
        id: dev
        with:
          tag_string: "2025.01-dev"

      - name: "Test snapshot tag"
        uses: ./
        id: snapshot
        with:
          tag_string: "1.0.0-SNAPSHOT"

      - name: "Test stable tag (not development)"
        uses: ./
        id: stable
        with:
          tag_string: "1.0.0"

      - name: "Verify stable not flagged as dev"
        shell: bash
        run: |
          if [ "${{ steps.stable.outputs.development_tag }}" \
            != "false" ]; then
            echo "Error: Stable tag incorrectly flagged as development"
            exit 1
          fi
          echo "âœ“ Development tag detection works correctly"

  ### Test All Input Combinations ###
  test-input-priority:
    name: "Test Input Priority"
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: "Test tag_location takes priority over tag_string"
        uses: ./
        id: priority-test
        with:
          tag_location: >-
            lfreleng-actions/test-tags-semantic/v0.1.2-unsigned
          tag_string: "this-should-be-ignored"
          permit_missing: true

      - name: "Verify tag_location was used"
        shell: bash
        run: |
          tag_name="${{ steps.priority-test.outputs.tag_name }}"
          if [[ "$tag_name" == *"ignored"* ]]; then
            echo "Error: tag_string was used instead of tag_location"
            exit 1
          fi
          echo "âœ“ Input priority works correctly"

  ### Test Edge Cases ###
  test-edge-cases:
    name: "Test Edge Cases"
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: "Test empty tag_string with permit_missing=true"
        uses: ./
        id: empty-string
        with:
          tag_string: ""
          permit_missing: true

      - name: "Test very long version string"
        uses: ./
        id: long-version
        with:
          tag_string: "1.0.0-beta.1+build.12345.abcdef1234567890"
          require_type: semver

      - name: "Test version with all dev keywords"
        uses: ./
        id: multi-dev
        with:
          tag_string: "1.0.0-alpha-pre-dev"

      - name: "Verify multiple dev keywords detected"
        shell: bash
        run: |
          if [ "${{ steps.multi-dev.outputs.development_tag }}" \
            != "true" ]; then
            echo "Error: Multiple dev keywords not detected"
            exit 1
          fi

      - name: "Test uppercase V prefix"
        uses: ./
        id: uppercase-v
        with:
          tag_string: "V1.0.0"

      - name: "Verify uppercase V detected"
        shell: bash
        run: |
          if [ "${{ steps.uppercase-v.outputs.version_prefix }}" \
            != "true" ]; then
            echo "Error: Uppercase V prefix not detected"
            exit 1
          fi
          echo "âœ“ Edge cases handled correctly"

  ### Summary ###
  ### Python Package Tests ###
  test-python-validation:
    name: "Test Python Version Validation"
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - name: "Set up Python"
        # yamllint disable-line rule:line-length
        uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548  # v6.1.0
        with:
          python-version: '3.11'

      - name: "Install package with dev dependencies"
        shell: bash
        run: |
          python -m pip install --upgrade pip
          python -m pip install -e ".[dev]"

      - name: "Test SemVer validation"
        shell: bash
        run: |
          # Test SemVer validation
          tag-validate validate "v1.2.3" --json | \
            jq -e '.success == true and .version_type == "semver"'

          tag-validate validate "1.0.0" --json | \
            jq -e '.success == true and .major == 1'

      - name: "Test CalVer validation"
        shell: bash
        run: |
          # Test CalVer validation
          tag-validate validate "2024.01.15" --json | \
            jq -e '.success == true and .version_type == "calver"'

          tag-validate validate "v2024.12.31" --json | \
            jq -e '.success == true and .year == 2024'

      - name: "Test development version detection"
        shell: bash
        run: |
          # Test development version detection
          tag-validate validate "v1.2.3-alpha" --json | \
            jq -e '.development_tag == true'

          tag-validate validate "v1.2.3-beta.1" --json | \
            jq -e '.development_tag == true'

          tag-validate validate "v1.2.3" --json | \
            jq -e '.development_tag == false'

      - name: "Test version type requirements"
        shell: bash
        run: |
          # Test requiring specific version type
          tag-validate validate "v1.2.3" --require-type semver \
            --json | jq -e '.success == true'

          # This should fail - wrong type
          if tag-validate validate "v1.2.3" --require-type calver \
            --json 2>&1; then
            echo "ERROR: Should have failed for wrong version type"
            exit 1
          fi

      - name: "Test strict SemVer mode"
        shell: bash
        run: |
          # Strict mode with prefix should return type 'other'
          tag-validate validate "v1.2.3" --strict-semver --json | \
            jq -e '.success == true and .version_type == "other"'

          # Strict mode should accept without prefix
          tag-validate validate "1.2.3" --strict-semver --json | \
            jq -e '.success == true and .version_type == "semver"'

  test-python-signature-detection:
    name: "Test Python Signature Detection"
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      - name: "Checkout test repo (SemVer)"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          repository: lfreleng-actions/test-tags-semantic
          fetch-depth: 0
          path: test-repo-semver

      - name: "Checkout test repo (CalVer)"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          repository: lfreleng-actions/test-tags-calver
          fetch-depth: 0
          path: test-repo-calver

      - name: "Checkout action code"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          path: action-code

      - name: "Set up Python"
        # yamllint disable-line rule:line-length
        uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548  # v6.1.0
        with:
          python-version: '3.11'

      - name: "Install package with dev dependencies"
        shell: bash
        working-directory: action-code
        run: |
          python -m pip install --upgrade pip
          python -m pip install -e ".[dev]"

      - name: "Import GPG test key for signature verification"
        id: import-gpg
        # Allow failure when GPG_PRIVATE_KEY secret is not set
        continue-on-error: true
        # yamllint disable-line rule:line-length
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          trust_level: ultimate

      - name: "Check GPG key availability"
        id: check-gpg-key
        shell: bash
        run: |
          if gpg --list-secret-keys "test@tag-validate-action.local" \
            &>/dev/null; then
            echo "gpg_available=true" >> "$GITHUB_OUTPUT"
            echo "âœ“ GPG test key available for verification"
          else
            echo "gpg_available=false" >> "$GITHUB_OUTPUT"
            echo "âš ï¸  GPG key not available (expected for PR from fork)"
            echo "â„¹ï¸  Tests will verify detection without verification"
          fi

      - name: "Test GPG signature detection (SemVer)"
        if: steps.check-gpg-key.outputs.gpg_available == 'true'
        shell: bash
        run: |
          # Test GPG signature detection
          cd test-repo-semver
          tag-validate detect v0.1.4-gpg-test --json | \
            jq -e '.signature_type == "gpg" and .is_valid == true'

      - name: "Test GPG signature detection without key (SemVer)"
        if: steps.check-gpg-key.outputs.gpg_available == 'false'
        shell: bash
        run: |
          # Without GPG key, signature should be detected but not verified
          # Note: detect exits with code 1 when unverified
          cd test-repo-semver
          result=$(tag-validate detect v0.1.4-gpg-test --json \
            2>&1 || true)
          echo "DEBUG: Full JSON output:"
          echo "$result"

          # Check that signature was detected (either gpg or gpg-unverifiable)
          sig_type=$(echo "$result" | jq -r '.signature_type // "unknown"')
          is_valid=$(echo "$result" | jq -r '.is_valid // false')

          echo "Signature type: $sig_type"
          echo "Is valid: $is_valid"

          if [[ "$sig_type" == "gpg-unverifiable" ]] || \
             [[ "$sig_type" == "gpg" ]]; then
            echo "âœ“ GPG signature detected (type: $sig_type)"
          else
            echo "âŒ Expected GPG signature, got: $sig_type"
            exit 1
          fi

          if [[ "$is_valid" == "false" ]]; then
            echo "âœ“ Signature is not verified (as expected without key)"
          else
            echo "âš ï¸  Signature verification status: $is_valid"
          fi

      - name: "Test SSH signature detection (SemVer)"
        shell: bash
        run: |
          # Test SSH signature detection
          # Note: SSH signatures may not be verified without allowed_signers
          cd test-repo-semver
          result=$(tag-validate detect v0.1.3-ssh-signed --json \
            || true)
          echo "$result" | jq -e '.signature_type == "ssh"'
          echo "âœ“ SSH signature detected"

      - name: "Test unsigned tag detection (SemVer)"
        shell: bash
        run: |
          # Test unsigned tag detection
          cd test-repo-semver
          tag-validate detect v0.1.2-unsigned --json | \
            jq -e '.signature_type == "unsigned"'

      - name: "Test GPG signature detection (CalVer)"
        if: steps.check-gpg-key.outputs.gpg_available == 'true'
        shell: bash
        run: |
          # Test GPG signature detection with key available
          cd test-repo-calver
          tag-validate detect 2025.1.4-gpg-test --json | \
            jq -e '.signature_type == "gpg" and .is_valid == true'

      - name: "Test GPG signature detection without key (CalVer)"
        if: steps.check-gpg-key.outputs.gpg_available == 'false'
        shell: bash
        run: |
          # Without GPG key, signature should be detected but not verified
          # Note: detect exits with code 1 when unverified
          cd test-repo-calver
          result=$(tag-validate detect 2025.1.4-gpg-test --json \
            2>&1 || true)
          echo "DEBUG: Full JSON output:"
          echo "$result"

          # Check that signature was detected (either gpg or gpg-unverifiable)
          sig_type=$(echo "$result" | jq -r '.signature_type // "unknown"')
          is_valid=$(echo "$result" | jq -r '.is_valid // false')

          echo "Signature type: $sig_type"
          echo "Is valid: $is_valid"

          if [[ "$sig_type" == "gpg-unverifiable" ]] || \
             [[ "$sig_type" == "gpg" ]]; then
            echo "âœ“ GPG signature detected (type: $sig_type)"
          else
            echo "âŒ Expected GPG signature, got: $sig_type"
            exit 1
          fi

          if [[ "$is_valid" == "false" ]]; then
            echo "âœ“ Signature is not verified (as expected without key)"
          else
            echo "âš ï¸  Signature verification status: $is_valid"
          fi

      - name: "Test SSH signature detection (CalVer)"
        shell: bash
        run: |
          # Test SSH signature detection
          # Note: SSH signatures may not be verified without allowed_signers
          cd test-repo-calver
          result=$(tag-validate detect 2025.1.3-ssh-signed --json \
            || true)
          echo "$result" | jq -e '.signature_type == "ssh"'
          echo "âœ“ SSH signature detected"

      - name: "Test unsigned tag detection (CalVer)"
        shell: bash
        run: |
          # Test unsigned tag detection
          cd test-repo-calver
          tag-validate detect 2025.1.2-unsigned --json | \
            jq -e '.signature_type == "unsigned"'

      - name: "Test summary"
        if: always()
        shell: bash
        run: |
          echo "=== Python Signature Detection Test Summary ==="
          if [ "${{ steps.check-gpg-key.outputs.gpg_available }}" = \
            "true" ]; then
            echo "âœ“ GPG key available - Full verification tests completed"
          else
            echo "â„¹ï¸  GPG key not available (PR from fork)"
            echo "âœ“ Signature detection tests completed" \
              "(without verification)"
            echo ""
            echo "This is expected behavior for pull requests" \
              "from forks."
            echo "GPG signatures are detected but not verified" \
              "without the key."
          fi

  test-python-tag-operations:
    name: "Test Python Tag Operations"
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      - name: "Checkout repository"
        # yamllint disable-line rule:line-length
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - name: "Set up Python"
        # yamllint disable-line rule:line-length
        uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548  # v6.1.0
        with:
          python-version: '3.11'

      - name: "Install package with dev dependencies"
        shell: bash
        run: |
          python -m pip install --upgrade pip
          python -m pip install -e ".[dev]"

      - name: "Test tag location parsing"
        shell: bash
        run: |
          # Test tag location parsing with Python
          python -c "
          from tag_validate.tag_operations import TagOperations

          ops = TagOperations()

          # Test basic format
          owner, repo, tag = ops.parse_tag_location('torvalds/linux@v6.0')
          assert owner == 'torvalds', f'Expected torvalds, got {owner}'
          assert repo == 'linux', f'Expected linux, got {repo}'
          assert tag == 'v6.0', f'Expected v6.0, got {tag}'

          # Test with HTTPS URL
          url = 'https://github.com/torvalds/linux@v6.0'
          owner, repo, tag = ops.parse_tag_location(url)
          assert owner == 'torvalds', f'Expected torvalds, got {owner}'
          assert repo == 'linux', f'Expected linux, got {repo}'

          # Test with .git suffix
          url = 'https://github.com/user/repo.git@v1.0.0'
          owner, repo, tag = ops.parse_tag_location(url)
          assert owner == 'user', f'Expected user, got {owner}'
          assert repo == 'repo', f'Expected repo, got {repo}'

          print('âœ… Tag location parsing tests passed')
          "

      - name: "Test repository info builder"
        shell: bash
        run: |
          # Test repository info builder
          python -c "
          from tag_validate.tag_operations import TagOperations

          ops = TagOperations()
          repo_info = ops.build_repository_info('torvalds', 'linux', 'v6.0')

          assert repo_info.owner == 'torvalds'
          assert repo_info.name == 'linux'
          assert repo_info.tag == 'v6.0'
          assert 'github.com/torvalds/linux' in repo_info.clone_url

          print('âœ… Repository info builder tests passed')
          "

  test-summary:
    name: "Test Results Summary"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs:
      - test-string-validation
      - test-local-tags
      - test-remote-tags
      - test-signatures
      - test-local-ssh-tags
      - test-signature-requirements
      - test-development-tags
      - test-input-priority
      - test-edge-cases
      - test-python-validation
      - test-python-signature-detection
      - test-python-tag-operations
    if: always()
    steps:
      - name: "Display test results"
        shell: bash
        run: |
          {
            echo "## Test Results Summary"
            echo ""
            echo "All test jobs completed!"
            echo ""
            echo "### Bash Action Tests"
            echo "âœ… String validation tests"
            echo "âœ… Local tag tests"
            echo "âœ… Remote tag tests"
            echo "âœ… Signature tests"
            echo "âœ… Development tag tests"
            echo "âœ… Input priority tests"
            echo "âœ… Edge case tests"
            echo ""
            echo "### Python Package Tests"
            echo "âœ… Python version validation tests"
            echo "âœ… Python signature detection tests"
            echo "âœ… Python tag operations tests"
          } >> "$GITHUB_STEP_SUMMARY"
