---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

# tag-validate-action
name: 'ðŸ·ï¸ Unified Tag Validation'
description: >-
  Validates tags for versioning compliance (SemVer/CalVer) and cryptographic
  signatures (SSH/GPG)

inputs:
  tag_location:
    description: >-
      Path to tag - supports two formats:
      1. Remote: ORG/REPO/TAG
      (e.g., lfreleng-actions/tag-validate-action/v0.1.0)
      2. Local: PATH/TO/REPO/TAG (e.g., ./my-repo/v1.0.0)
      Local paths must contain a .git directory
    required: false
    default: ''
  tag_string:
    description: >-
      Tag string to validate (version format only, no signature check)
    required: false
    default: ''
  require_type:
    description: 'Required tag type (semver|calver|none)'
    required: false
    default: 'none'
  require_signed:
    description: >-
      Signature requirement:
      - true: Require ANY verified signature (gpg or ssh)
      - gpg: Require verified GPG signature
      - ssh: Require verified SSH signature
      - gpg-unverifiable: Require GPG signature (verification optional)
      - signed: Require any signature type (including unverifiable)
      - false: Must be unsigned
      - ambivalent: Don't care (default)
    required: false
    default: 'ambivalent'
  verify_github:
    description: >-
      Verify that the signing key is registered on the GitHub account
      of the tag creator. Requires a GitHub token.
    required: false
    default: 'false'
  permit_missing:
    description: 'Allow missing tags without error'
    required: false
    default: 'false'
  token:
    description: >-
      GitHub token for authenticated API calls and private repository access
    required: false
    default: ''
  github_server_url:
    description: >-
      GitHub server URL for git operations (supports GitHub Enterprise Server).
      If not provided, falls back to GITHUB_SERVER_URL environment variable or
      https://github.com
    required: false
    default: ''
  debug:
    description: 'Enable debug output in action logs'
    required: false
    default: 'false'
  use_local_action:
    description: >-
      Use local repository action/code instead of the PyPI package.
      Set to 'true' when testing changes in a fork or branch before merging.
    required: false
    default: 'false'

outputs:
  valid:
    description: 'Set true if tag passes validation checks'
    value: ${{ steps.validate.outputs.valid }}
  tag_type:
    description: 'Detected tag type (semver|calver|both|unknown)'
    value: ${{ steps.validate.outputs.tag_type }}
  signing_type:
    # yamllint disable rule:line-length
    description: 'Detected signing type (gpg|ssh|unsigned|lightweight|invalid|gpg-unverifiable)'
    value: ${{ steps.validate.outputs.signing_type }}
  development_tag:
    description: 'Set true if development/pre-release tag detected'
    value: ${{ steps.validate.outputs.development_tag }}
  version_prefix:
    description: 'Set true if tag has version prefix (v or V)'
    value: ${{ steps.validate.outputs.version_prefix }}
  tag_name:
    description: 'The tag name being validated'
    value: ${{ steps.validate.outputs.tag_name }}

runs:
  using: 'composite'
  steps:
    # yamllint disable rule:line-length
    - name: 'Set up Python'
      uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548 # v6.1.0
      with:
        python-version: '3.12'

    - name: 'Install uv'
      if: inputs.use_local_action != 'true' && !contains(github.repository, 'lfreleng-actions/tag-validate-action')
      uses: astral-sh/setup-uv@61cb8a9741eeb8a550a1b8544337180c0fc8476b # v7.2.0

    - name: 'Install local dependencies'
      if: inputs.use_local_action == 'true' || contains(github.repository, 'lfreleng-actions/tag-validate-action')
      shell: bash
      run: |
        pip install -e "${{ github.action_path }}"

    - name: 'Fetch tag objects'
      shell: bash
      run: |
        # Ensure we have the actual tag object, not just the ref
        # This is necessary because checkout might only fetch tag refs, not tag objects
        if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
          TAG_NAME="${GITHUB_REF_NAME:-}"
          echo "Fetching tag object for: ${TAG_NAME}"
          git fetch origin "refs/tags/${TAG_NAME}:refs/tags/${TAG_NAME}" --force || true
          TAG_TYPE=$(git cat-file -t "${TAG_NAME}" 2>/dev/null || echo "unknown")
          echo "Tag object type: ${TAG_TYPE}"
        fi

    - name: 'Validate tag'
      id: validate
      shell: bash
      run: |
        # Run tag-validate Python CLI with JSON output
        set -euo pipefail

        # Normalize inputs to lowercase for case-insensitive matching
        REQUIRE_TYPE=$(echo "${{ inputs.require_type }}" | tr '[:upper:]' '[:lower:]')
        REQUIRE_SIGNED=$(echo "${{ inputs.require_signed }}" | tr '[:upper:]' '[:lower:]')
        VERIFY_GITHUB=$(echo "${{ inputs.verify_github }}" | tr '[:upper:]' '[:lower:]')
        PERMIT_MISSING=$(echo "${{ inputs.permit_missing }}" | tr '[:upper:]' '[:lower:]')
        DEBUG=$(echo "${{ inputs.debug }}" | tr '[:upper:]' '[:lower:]')

        # Build command arguments
        ARGS=("--json")
        USE_VERSION_ONLY="false"

        # Determine tag location or string
        if [ -n "${{ inputs.tag_location }}" ]; then
          TAG_LOCATION="${{ inputs.tag_location }}"
          # Python CLI now handles format normalization (owner/repo/tag â†’ owner/repo@tag)
        elif [ -n "${{ inputs.tag_string }}" ]; then
          # For tag_string, use validate-version command
          USE_VERSION_ONLY="true"
          TAG_LOCATION="${{ inputs.tag_string }}"
        elif [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
          # Auto-detect from tag push event
          TAG_LOCATION="${GITHUB_REF_NAME:-}"
          echo "ðŸ·ï¸ Tag push event detected: ${TAG_LOCATION}"
        elif [ "${PERMIT_MISSING}" = "true" ]; then
          # Handle missing tag with permit_missing=true
          echo "â„¹ï¸ No tag found, but permit_missing=true"
          # Write minimal outputs and exit successfully
          cat >> "${GITHUB_OUTPUT}" << 'EOFOUTPUT'
        valid=true
        tag_type=unknown
        signing_type=unsigned
        development_tag=false
        version_prefix=false
        tag_name=
        EOFOUTPUT
          exit 0
        else
          echo "Error: Either tag_location or tag_string must be provided" >&2
          exit 1
        fi

        # Add validation options
        # Common args for both validate and verify commands
        COMMON_ARGS=()

        # Add --require-type if it's not empty (including "none")
        if [ -n "${REQUIRE_TYPE}" ]; then
          COMMON_ARGS+=("--require-type" "${REQUIRE_TYPE}")
        fi

        # Signature-specific args only for verify command
        VERIFY_ARGS=()

        # Handle require_signed variations
        # Values: true, gpg, ssh, gpg-unverifiable, signed, false, ambivalent
        case "${REQUIRE_SIGNED}" in
          true)
            # Require any verified signature (gpg or ssh)
            VERIFY_ARGS+=("--require-signed" "true")
            ;;
          gpg|ssh)
            # Require specific signature type (verified)
            VERIFY_ARGS+=("--require-signed" "${REQUIRE_SIGNED}")
            ;;
          gpg-unverifiable)
            # Require GPG signature but don't enforce verification
            VERIFY_ARGS+=("--require-signed" "gpg-unverifiable")
            ;;
          signed)
            # Require any signature (including unverifiable)
            VERIFY_ARGS+=("--require-signed" "signed")
            ;;
          false)
            # Explicitly require unsigned
            VERIFY_ARGS+=("--require-signed" "false")
            ;;
          ambivalent)
            # Don't add --require-signed flag (don't care)
            ;;
        esac

        # Add GitHub key verification if requested
        if [ "${VERIFY_GITHUB}" = "true" ]; then
          VERIFY_ARGS+=("--verify-github-key")
        fi

        # Add owner if provided
        if [ -n "${{ inputs.owner }}" ]; then
          VERIFY_ARGS+=("--owner" "${{ inputs.owner }}")
        fi

        # Add permit_missing flag if enabled (applies to both)
        if [ "${PERMIT_MISSING}" = "true" ]; then
          COMMON_ARGS+=("--permit-missing")
        fi

        # GitHub token is passed via GITHUB_TOKEN environment variable (see env section below)
        # This is more secure than passing it as a CLI argument

        # Enable debug output
        if [ "${DEBUG}" = "true" ]; then
          set -x
        fi

        # Determine which CLI invocation method to use
        if [[ "${{ inputs.use_local_action }}" == "true" ]] || \
           [[ "${{ github.repository }}" =~ lfreleng-actions/tag-validate-action ]]; then
          CLI_CMD="python -m tag_validate.cli"
          echo "Using local action code: ${CLI_CMD}"
        else
          # Use PyPI package via uvx
          # The --quiet flag is critical to suppress uvx's download progress output,
          # which would otherwise mix with the JSON output from tag-validate and cause parsing errors
          CLI_CMD="uvx --quiet --from tag-validate tag-validate"
          echo "Using PyPI package via uvx"
        fi

        # Execute validation and capture output
        # Display exact command being executed for debugging
        # Note: This is safe to log because sensitive data (GITHUB_TOKEN) is passed via
        # environment variable (see env section below), NOT as a CLI argument
        EXIT_CODE=0
        if [ "${USE_VERSION_ONLY}" = "true" ]; then
          # validate command only uses common args (no signature args)
          echo "ðŸ” Executing: ${CLI_CMD} validate \"${TAG_LOCATION}\" ${COMMON_ARGS[@]} --json"
          JSON_OUTPUT=$(${CLI_CMD} validate "${TAG_LOCATION}" "${COMMON_ARGS[@]}" --json 2>&1) || EXIT_CODE=$?
        else
          # verify command uses both common and verify-specific args
          ALL_VERIFY_ARGS=("${COMMON_ARGS[@]}" "${VERIFY_ARGS[@]}")
          echo "ðŸ” Executing: ${CLI_CMD} verify \"${TAG_LOCATION}\" ${ALL_VERIFY_ARGS[@]} --json"
          JSON_OUTPUT=$(${CLI_CMD} verify "${TAG_LOCATION}" "${ALL_VERIFY_ARGS[@]}" --json 2>&1) || EXIT_CODE=$?
        fi

        # Extract and validate JSON from output using Python
        # This handles cases where uvx might include non-JSON output
        # Python is already available from the setup-python step above
        cat > /tmp/extract_json.py << 'EOF'
        import json
        import sys

        # Read raw output from stdin
        text = sys.stdin.read()

        # Try to find the first valid JSON object in the output
        decoder = json.JSONDecoder()
        start = text.find('{')
        max_attempts = 10  # Prevent infinite loops in malformed data
        attempts = 0
        while start != -1 and attempts < max_attempts:
            attempts += 1
            try:
                # Parse the JSON starting at this position without slicing
                obj, _ = decoder.raw_decode(text, idx=start)
                # Re-serialize to ensure we have clean, valid JSON only
                clean_json = json.dumps(obj, ensure_ascii=False)
                print(clean_json, end='')
                sys.exit(0)
            except (json.JSONDecodeError, ValueError):
                # Not valid JSON at this position, search for the next candidate
                start = text.find('{', start + 1)

        # No valid JSON found
        print('ERROR: No valid JSON object found in output', file=sys.stderr)
        sys.exit(1)
        EOF

        EXTRACTED_JSON=$(echo "${JSON_OUTPUT}" | python3 /tmp/extract_json.py)
        EXTRACT_EXIT_CODE=$?

        if [ ${EXTRACT_EXIT_CODE} -ne 0 ]; then
          echo "Error: Failed to extract valid JSON from tag-validate CLI output" >&2
          echo "Raw output was:" >&2
          echo "${JSON_OUTPUT}" >&2
          exit 1
        fi

        # Display the extracted JSON
        echo "${EXTRACTED_JSON}"

        # Use the extracted JSON for further processing
        JSON_OUTPUT="${EXTRACTED_JSON}"

        # Python CLI now handles permit_missing logic internally
        # If exit code is 0, validation succeeded (or was permitted to pass)
        # If exit code is non-zero, validation failed

        # Parse JSON output using Python (bundled with actions/setup-python)
        # Create temporary Python script to avoid YAML parsing issues
        cat > /tmp/parse_output.py << 'PYEOF'
        import json
        import sys
        import os
        import re

        json_output = sys.argv[1]

        try:
            data = json.loads(json_output)
            success = str(data.get("success", False)).lower()
            tag_name = data.get("tag_name", data.get("version", ""))
            version_type = data.get("version_type", data.get("detected_type", "unknown")) or "unknown"
            signature_type = data.get("signature_type", "unsigned") or "unsigned"

            # Determine development tag
            # Support both new (development_tag) and old (is_development) field names for backwards compatibility
            is_dev = "false"
            if data.get("development_tag", False) or data.get("is_development", False):
                is_dev = "true"
            # Fallback: check tag name for development indicators (for backwards compatibility)
            elif tag_name and re.search(r"(dev|pre|alpha|beta|rc|snapshot|nightly|canary|preview)", tag_name.lower()):
                is_dev = "true"

            # Determine version prefix
            # Support both new (version_prefix) and old (has_prefix) field names for backwards compatibility
            has_prefix = "false"
            if data.get("version_prefix", False) or data.get("has_prefix", False):
                has_prefix = "true"
            # Fallback: check tag name directly (for backwards compatibility)
            elif tag_name and tag_name[0:1] in ("v", "V"):
                has_prefix = "true"

            # Write to GITHUB_OUTPUT in single block
            with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                f.write(f"valid={success}\n")
                f.write(f"tag_type={version_type}\n")
                f.write(f"signing_type={signature_type}\n")
                f.write(f"development_tag={is_dev}\n")
                f.write(f"version_prefix={has_prefix}\n")
                f.write(f"tag_name={tag_name}\n")

            # Exit with appropriate code
            sys.exit(0 if success == "true" else 1)

        except Exception as e:
            print(f"Error parsing JSON output: {e}", file=sys.stderr)
            print(f"JSON output was: {json_output}", file=sys.stderr)
            sys.exit(1)
        PYEOF

        # Execute the Python script with JSON output as argument
        python /tmp/parse_output.py "${JSON_OUTPUT}"

        # Exit code is already set by Python script above
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
        GITHUB_SERVER_URL: ${{ inputs.github_server_url || env.GITHUB_SERVER_URL || 'https://github.com' }}
