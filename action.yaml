---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

# tag-validate-action
name: 'ðŸ·ï¸ Unified Tag Validation'
description: >-
  Validates tags for versioning compliance (SemVer/CalVer) and cryptographic
  signatures (SSH/GPG)

inputs:
  tag_location:
    description: >-
      Path to tag - supports two formats:
      1. Remote: ORG/REPO/TAG
      (e.g., lfreleng-actions/tag-validate-action/v0.1.0)
      2. Local: PATH/TO/REPO/TAG (e.g., ./my-repo/v1.0.0)
      Local paths must contain a .git directory
    required: false
    default: ''
  tag_string:
    description: >-
      Tag string to validate (version format only, no signature check)
    required: false
    default: ''
  require_type:
    description: >-
      Required tag type: semver, calver, both, none (comma-separated for
      multiple). When omitted or set to 'none', any format is accepted
      (including customtags). Examples: 'semver', 'semver,calver', 'none'.
    required: false
    default: ''
  require_signed:
    description: >-
      Signature requirement (comma-separated for multiple, e.g., 'gpg,ssh'):
      - gpg: Require verified GPG signature
      - ssh: Require verified SSH signature
      - gpg-unverifiable: Accept GPG signature without verification
      - unsigned: Must be unsigned
      Omit for no signature requirement.
    required: false
    default: ''
  require_github:
    description: >-
      Requires that the signing key is registered to a GitHub account.
      Requires a GitHub token.
    required: false
    default: 'false'
  require_gerrit:
    description: >-
      Requires that the signing key is registered to a Gerrit account.
      Set to 'true' to auto-detect Gerrit server from GitHub org
      (pattern: gerrit.[org].org),
      or provide a specific Gerrit server hostname/URL
      (e.g., 'gerrit.onap.org').
    required: false
    default: 'false'
  require_owner:
    description: >-
      GitHub username(s) or email address(es) that must own the signing key
      (comma or space-separated for multiple, e.g., 'octocat,monalisa' or
      'user@example.com').
      Requires a GitHub token. When specified, require_github is implied.
    required: false
    default: ''
  gerrit_username:
    description: >-
      Gerrit username for HTTP authentication. Required for Gerrit servers
      that restrict public access to user key information. Can also be set
      via GERRIT_USERNAME environment variable. WARNING: Do NOT store this
      as a GitHub secret. GitHub Actions masks secret values in all outputs,
      which will cause the username to appear as '***' in the step summary
      if it matches the key owner's username. Only the password is sensitive.
    required: false
    default: ''
  gerrit_password:
    description: >-
      Gerrit HTTP password for authentication. This must be an HTTP password
      generated from your Gerrit account settings (Settings > HTTP Credentials),
      NOT your SSO/LDAP password. Required when gerrit_username is provided.
      Can also be set via GERRIT_PASSWORD environment variable.
    required: false
    default: ''
  reject_development:
    description: >-
      Reject development/pre-release tags (tags containing alpha, beta, rc, dev,
      pre, snapshot, nightly, canary, or preview). When enabled, validation will
      fail for any tag identified as a development version.
    required: false
    default: 'false'
  permit_missing:
    description: 'Allow missing tags without error'
    required: false
    default: 'false'
  token:
    description: >-
      GitHub token for authenticated API calls and private repository access
    required: false
    default: ''
  github_server_url:
    description: >-
      GitHub server URL for git operations (supports GitHub Enterprise Server).
      If not provided, falls back to GITHUB_SERVER_URL environment variable or
      https://github.com
    required: false
    default: ''
  debug:
    description: >-
      Enable debug output in action logs. This enables both bash command
      tracing (set -x) and Python verbose logging (--verbose flag), providing
      comprehensive debugging information including git operations, API calls,
      and internal validation steps.
    required: false
    default: 'false'
  use_local_action:
    description: >-
      Use local repository action/code instead of the PyPI package.
      Set to 'true' when testing changes in a fork or branch before merging.
    required: false
    default: 'false'
  upload_json:
    description: >-
      Upload validation results as JSON artifact to the workflow run.
      The artifact includes detailed validation information in JSON format.
    required: false
    default: 'true'
  json_upload_format:
    description: >-
      JSON artifact format: 'compact', 'pretty', or 'both'.
      Compact format is single-line, pretty format is indented for readability.
    required: false
    default: 'pretty'
  github_step_summary:
    description: >-
      Write validation summary to GitHub Actions step summary.
      Automatically detects GitHub Actions environment.
    required: false
    default: 'true'

outputs:
  valid:
    description: 'Set true if tag passes validation checks'
    value: ${{ steps.validate.outputs.valid }}
  tag_type:
    description: 'Detected tag type (semver|calver|both|other|unknown)'
    value: ${{ steps.validate.outputs.tag_type }}
  signing_type:
    # yamllint disable rule:line-length
    description: 'Detected signing type (gpg|ssh|unsigned|lightweight|invalid|gpg-unverifiable)'
    value: ${{ steps.validate.outputs.signing_type }}
  development_tag:
    description: 'Set true if development/pre-release tag detected'
    value: ${{ steps.validate.outputs.development_tag }}
  version_prefix:
    description: 'Set true if tag has version prefix (v or V)'
    value: ${{ steps.validate.outputs.version_prefix }}
  tag_name:
    description: 'The tag name being validated'
    value: ${{ steps.validate.outputs.tag_name }}
  artifact_path:
    description: 'Path to the JSON artifact file (if uploaded)'
    value: ${{ steps.validate.outputs.artifact_path }}
  artifact_suffix:
    description: 'Unique suffix for artifact naming (to avoid conflicts)'
    value: ${{ steps.validate.outputs.artifact_suffix }}

runs:
  using: 'composite'
  steps:
    # yamllint disable rule:line-length
    - name: 'Set up Python'
      uses: actions/setup-python@a309ff8b426b58ec0e2a45f0f869d46889d02405 # v6.2.0
      with:
        python-version: '3.12'

    - name: 'Install uv'
      if: inputs.use_local_action != 'true' && !contains(github.repository, 'lfreleng-actions/tag-validate-action')
      uses: astral-sh/setup-uv@803947b9bd8e9f986429fa0c5a41c367cd732b41 # v7.2.1

    - name: 'Install local dependencies'
      if: inputs.use_local_action == 'true' || contains(github.repository, 'lfreleng-actions/tag-validate-action')
      shell: bash
      run: |
        # Install dependencies without the package itself to avoid setuptools-scm issues
        pip install dependamerge>=0.1.19 aiolimiter>=1.2.1 "httpx[http2]>=0.28.1" pydantic>=2.12.5 rich>=14.2.0 typer>=0.21.1 python-gnupg>=0.5.3 cryptography>=46.0.3 packaging>=24.2 pygerrit2>=2.0.15
        # Add the source directory to PYTHONPATH for direct module access
        echo "PYTHONPATH=${{ github.action_path }}/src:${PYTHONPATH:-}" >> "$GITHUB_ENV"

    - name: 'Verify Python module import'
      if: inputs.use_local_action == 'true' || contains(github.repository, 'lfreleng-actions/tag-validate-action')
      shell: bash
      run: |
        # Test if the Python module can be imported
        echo "ðŸ” Testing Python module import..."
        echo "PYTHONPATH: ${PYTHONPATH}"
        echo "Python sys.path:"
        python -c "import sys; print('\n'.join(sys.path))"
        echo ""
        echo "Attempting to import tag_validate module..."
        python -c "import tag_validate; print('âœ… tag_validate module imported successfully'); import tag_validate; print('Module location:', tag_validate.__file__)" || {
          echo "âŒ Failed to import tag_validate module" >&2
          echo "Directory contents of src/:" >&2
          ls -la "${{ github.action_path }}/src/" || echo "src/ directory not found" >&2
          echo "Directory contents of src/tag_validate/:" >&2
          ls -la "${{ github.action_path }}/src/tag_validate/" || echo "src/tag_validate/ directory not found" >&2
          exit 1
        }
        echo ""
        echo "Testing CLI entry point..."
        python -m tag_validate.cli --version || {
          echo "âŒ Failed to run CLI --version" >&2
          exit 1
        }
        echo "âœ… All import tests passed"

    - name: 'Fetch tag objects'
      shell: bash
      run: |
        # Ensure we have the actual tag object, not just the ref
        # This is necessary because checkout might only fetch tag refs, not tag objects
        if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
          TAG_NAME="${GITHUB_REF_NAME:-}"
          echo "Fetching tag object for: ${TAG_NAME}"
          git fetch origin "refs/tags/${TAG_NAME}:refs/tags/${TAG_NAME}" --force || true
          TAG_TYPE=$(git cat-file -t "${TAG_NAME}" 2>/dev/null || echo "unknown")
          echo "Tag object type: ${TAG_TYPE}"
        fi

    - name: 'Validate tag'
      id: validate
      shell: bash
      run: |
        # Run tag-validate Python CLI with rich output
        set -euo pipefail

        # Normalize inputs to lowercase for case-insensitive matching
        REQUIRE_TYPE=$(echo "${{ inputs.require_type }}" | tr '[:upper:]' '[:lower:]' | tr -d ' ')
        REQUIRE_SIGNED=$(echo "${{ inputs.require_signed }}" | tr '[:upper:]' '[:lower:]' | tr -d ' ')
        REQUIRE_GITHUB=$(echo "${{ inputs.require_github }}" | tr '[:upper:]' '[:lower:]')
        REQUIRE_GERRIT=$(echo "${{ inputs.require_gerrit }}" | tr '[:upper:]' '[:lower:]')
        REQUIRE_OWNER="${{ inputs.require_owner }}"
        REJECT_DEVELOPMENT=$(echo "${{ inputs.reject_development }}" | tr '[:upper:]' '[:lower:]')
        PERMIT_MISSING=$(echo "${{ inputs.permit_missing }}" | tr '[:upper:]' '[:lower:]')
        DEBUG=$(echo "${{ inputs.debug }}" | tr '[:upper:]' '[:lower:]')
        USE_LOCAL_ACTION=$(echo "${{ inputs.use_local_action }}" | tr '[:upper:]' '[:lower:]')
        UPLOAD_JSON=$(echo "${{ inputs.upload_json }}" | tr '[:upper:]' '[:lower:]')
        JSON_UPLOAD_FORMAT=$(echo "${{ inputs.json_upload_format }}" | tr '[:upper:]' '[:lower:]')
        GITHUB_STEP_SUMMARY_ENABLED=$(echo "${{ inputs.github_step_summary }}" | tr '[:upper:]' '[:lower:]')

        # Build command arguments
        USE_VERSION_ONLY="false"

        # Determine tag location or string
        if [ -n "${{ inputs.tag_location }}" ]; then
          TAG_LOCATION="${{ inputs.tag_location }}"
          # Python CLI now handles format normalization (owner/repo/tag â†’ owner/repo@tag)
        elif [ -n "${{ inputs.tag_string }}" ]; then
          # For tag_string, use validate-version command
          USE_VERSION_ONLY="true"
          TAG_LOCATION="${{ inputs.tag_string }}"
        elif [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
          # Auto-detect from tag push event
          TAG_LOCATION="${GITHUB_REF_NAME:-}"
          echo "ðŸ·ï¸ Tag push event detected: ${TAG_LOCATION}"
        elif [ "${PERMIT_MISSING}" = "true" ]; then
          # Handle missing tag with permit_missing=true
          echo "â„¹ï¸ No tag found, but permit_missing=true"
          # Write minimal outputs and exit successfully
          cat >> "${GITHUB_OUTPUT}" << 'EOFOUTPUT'
        valid=true
        tag_type=unknown
        signing_type=unsigned
        development_tag=false
        version_prefix=false
        tag_name=
        EOFOUTPUT
          exit 0
        else
          echo "Error: Either tag_location or tag_string must be provided" >&2
          exit 1
        fi

        # Add validation options
        # Common args for both validate and verify commands
        COMMON_ARGS=()

        # Add --require-type if it's not empty (supports comma-separated values)
        if [ -n "${REQUIRE_TYPE}" ]; then
          COMMON_ARGS+=("--require-type" "${REQUIRE_TYPE}")
        fi

        # Signature-specific args only for verify command
        VERIFY_ARGS=()

        # Add --require-signed if it's not empty (supports comma-separated values)
        # Values: gpg, ssh, gpg-unverifiable, unsigned (or comma-separated combinations)
        # Handle backward compatibility for boolean values
        if [ -n "${REQUIRE_SIGNED}" ]; then
          # Convert boolean values for backward compatibility
          case "${REQUIRE_SIGNED}" in
            "true")
              # For backward compatibility: true means require any valid signature
              VERIFY_ARGS+=("--require-signed" "gpg,ssh")
              ;;
            "false")
              # For backward compatibility: false means accept unsigned
              VERIFY_ARGS+=("--require-signed" "unsigned")
              ;;
            *)
              # Pass through specific signature types as-is
              VERIFY_ARGS+=("--require-signed" "${REQUIRE_SIGNED}")
              ;;
          esac
        fi

        # Add GitHub key verification if requested
        if [ "${REQUIRE_GITHUB}" = "true" ]; then
          VERIFY_ARGS+=("--require-github")
        fi

        # Add Gerrit key verification if requested
        if [ -n "${REQUIRE_GERRIT}" ] && [ "${REQUIRE_GERRIT}" != "false" ]; then
          VERIFY_ARGS+=("--require-gerrit" "${REQUIRE_GERRIT}")
        fi

        # Add Gerrit authentication if provided
        if [ -n "${{ inputs.gerrit_username }}" ]; then
          VERIFY_ARGS+=("--gerrit-username" "${{ inputs.gerrit_username }}")
        fi
        if [ -n "${{ inputs.gerrit_password }}" ]; then
          VERIFY_ARGS+=("--gerrit-password" "${{ inputs.gerrit_password }}")
        fi

        # Add require-owner if provided (comma or space separated values)
        if [ -n "${REQUIRE_OWNER}" ]; then
          VERIFY_ARGS+=("--require-owner" "${REQUIRE_OWNER}")
        fi

        # Add reject-development flag if enabled (only for verify command)
        if [ "${REJECT_DEVELOPMENT}" = "true" ]; then
          VERIFY_ARGS+=("--reject-development")
        fi

        # Add permit_missing flag if enabled (applies to both)
        if [ "${PERMIT_MISSING}" = "true" ]; then
          COMMON_ARGS+=("--permit-missing")
        fi

        # GitHub token is passed via GITHUB_TOKEN environment variable (see env section below)
        # This is more secure than passing it as a CLI argument

        # Enable debug output
        if [ "${DEBUG}" = "true" ]; then
          set -x
        fi

        # Determine which CLI invocation method to use
        if [[ "${USE_LOCAL_ACTION}" == "true" ]] || \
           [[ "${{ github.repository }}" =~ lfreleng-actions/tag-validate-action ]]; then
          CLI_CMD="python -m tag_validate.cli"
          echo "Using local action code: ${CLI_CMD}"
        else
          # Use PyPI package via uvx
          # The --quiet flag is critical to suppress uvx's download progress output,
          # which would otherwise mix with the JSON output from tag-validate and cause parsing errors
          CLI_CMD="uvx --quiet --from tag-validate tag-validate"
          echo "Using PyPI package via uvx"
        fi

        # Execute validation and capture output
        # Display exact command being executed for debugging
        # Note: This is safe to log because sensitive data (GITHUB_TOKEN) is passed via
        # environment variable (see env section below), NOT as a CLI argument
        EXIT_CODE=0
        # Add --verbose flag when debug is enabled for comprehensive Python logging
        VERBOSE_FLAG=""
        if [ "${DEBUG}" = "true" ]; then
          VERBOSE_FLAG="--verbose"
        fi

        if [ "${USE_VERSION_ONLY}" = "true" ]; then
          # validate command only uses common args (no signature args)
          # Note: validate command doesn't support --github-step-summary or --json-file flags

          # If upload_json is enabled, add --json-file flag to write JSON while showing rich output
          if [ "${UPLOAD_JSON}" = "true" ]; then
            # Create temp file for JSON output
            JSON_FILE="${RUNNER_TEMP}/tag-validate-output.json"
            COMMON_ARGS+=("--json-file" "${JSON_FILE}")
          fi

          echo "ðŸ” Executing: ${CLI_CMD} ${VERBOSE_FLAG} validate \"${TAG_LOCATION}\" ${COMMON_ARGS[@]}"
          ${CLI_CMD} ${VERBOSE_FLAG} validate "${TAG_LOCATION}" "${COMMON_ARGS[@]}" || EXIT_CODE=$?
          echo ""  # Add blank line after rich output

          # Read JSON from file if it was created
          if [ "${UPLOAD_JSON}" = "true" ] && [ -f "${JSON_FILE}" ]; then
            JSON_OUTPUT=$(cat "${JSON_FILE}")
            rm -f "${JSON_FILE}"
          fi
        else
          # verify command uses both common and verify-specific args
          ALL_VERIFY_ARGS=("${COMMON_ARGS[@]}" "${VERIFY_ARGS[@]}")

          # Add --github-step-summary or --no-github-step-summary flag
          if [ "${GITHUB_STEP_SUMMARY_ENABLED}" = "true" ]; then
            ALL_VERIFY_ARGS+=("--github-step-summary")
          else
            ALL_VERIFY_ARGS+=("--no-github-step-summary")
          fi

          # If upload_json is enabled, add --json-file flag to write JSON while showing rich output
          if [ "${UPLOAD_JSON}" = "true" ]; then
            # Create temp file for JSON output
            JSON_FILE="${RUNNER_TEMP}/tag-validate-output.json"
            ALL_VERIFY_ARGS+=("--json-file" "${JSON_FILE}")
          fi

          echo "ðŸ” Executing: ${CLI_CMD} ${VERBOSE_FLAG} verify \"${TAG_LOCATION}\" ${ALL_VERIFY_ARGS[@]}"
          ${CLI_CMD} ${VERBOSE_FLAG} verify "${TAG_LOCATION}" "${ALL_VERIFY_ARGS[@]}" || EXIT_CODE=$?
          echo ""  # Add blank line after rich output

          # Read JSON from file if it was created
          if [ "${UPLOAD_JSON}" = "true" ] && [ -f "${JSON_FILE}" ]; then
            JSON_OUTPUT=$(cat "${JSON_FILE}")
            rm -f "${JSON_FILE}"
          fi
        fi

        # Handle JSON artifact upload if enabled
        if [ "${UPLOAD_JSON}" = "true" ] && [ -n "${JSON_OUTPUT:-}" ]; then
          # Validate JSON using Python
          python3 -c "import json; json.loads('''${JSON_OUTPUT}''')" 2>/dev/null || {
            echo "Warning: Invalid JSON for artifact upload" >&2
            echo "Continuing without artifact upload..." >&2
            UPLOAD_JSON="false"
          }
        fi

        # Generate artifact suffix (timestamp + random hex for uniqueness)
        if [ "${UPLOAD_JSON}" = "true" ]; then
          ARTIFACT_SUFFIX=$(python3 -c "
        import secrets
        from datetime import datetime, timezone
        now = datetime.now(timezone.utc)
        datetime_str = now.strftime('%Y%m%d-%H%M%S')
        random_hex = secrets.token_hex(2)  # 4 hex chars
        print(f'{datetime_str}-{random_hex}')
        ")

          # Create artifact directory
          ARTIFACT_DIR="${RUNNER_TEMP}/tag-validate-${ARTIFACT_SUFFIX}"
          mkdir -p "${ARTIFACT_DIR}"

          # Write JSON files based on format preference
          case "${JSON_UPLOAD_FORMAT}" in
            compact)
              echo "${JSON_OUTPUT}" > "${ARTIFACT_DIR}/tag-validation.json"
              ;;
            pretty)
              echo "${JSON_OUTPUT}" | python3 -m json.tool > "${ARTIFACT_DIR}/tag-validation-pretty.json"
              ;;
            both)
              echo "${JSON_OUTPUT}" > "${ARTIFACT_DIR}/tag-validation.json"
              echo "${JSON_OUTPUT}" | python3 -m json.tool > "${ARTIFACT_DIR}/tag-validation-pretty.json"
              ;;
            *)
              echo "Warning: Invalid json_upload_format '${JSON_UPLOAD_FORMAT}', defaulting to 'pretty'" >&2
              echo "${JSON_OUTPUT}" | python3 -m json.tool > "${ARTIFACT_DIR}/tag-validation-pretty.json"
              ;;
          esac

          echo "âœ… JSON artifact created: ${ARTIFACT_DIR}"
        else
          ARTIFACT_SUFFIX=""
          ARTIFACT_DIR=""
        fi

        # Parse JSON output for GitHub outputs (using JSON if available, or defaults)

        # Create temporary Python script to avoid YAML parsing issues
        cat > /tmp/parse_output.py << 'PYEOF'
        import json
        import sys
        import os
        import re

        json_output = sys.argv[1] if len(sys.argv) > 1 else ""
        exit_code = int(sys.argv[2]) if len(sys.argv) > 2 else 0
        artifact_dir = sys.argv[3] if len(sys.argv) > 3 else ""
        artifact_suffix = sys.argv[4] if len(sys.argv) > 4 else ""

        # Default values
        success = "true" if exit_code == 0 else "false"
        tag_name = ""
        version_type = "unknown"
        signature_type = "unsigned"
        is_dev = "false"
        has_prefix = "false"

        # Try to parse JSON if available
        if json_output:
            try:
                data = json.loads(json_output)
                success = str(data.get("success", False)).lower()
                tag_name = data.get("tag_name", data.get("version", ""))
                version_type = data.get("version_type", data.get("detected_type", "unknown")) or "unknown"
                # Map 'other' to 'other' (custom format), keep all other values as-is
                if version_type not in ["semver", "calver", "both", "other"]:
                    version_type = "unknown"
                signature_type = data.get("signature_type", "unsigned") or "unsigned"

                # Determine development tag
                # Support both new (development_tag) and old (is_development) field names for backwards compatibility
                if data.get("development_tag", False) or data.get("is_development", False):
                    is_dev = "true"
                # Fallback: check tag name for development indicators (for backwards compatibility)
                elif tag_name and re.search(r"(dev|pre|alpha|beta|rc|snapshot|nightly|canary|preview)", tag_name.lower()):
                    is_dev = "true"

                # Determine version prefix
                # Support both new (version_prefix) and old (has_prefix) field names for backwards compatibility
                if data.get("version_prefix", False) or data.get("has_prefix", False):
                    has_prefix = "true"
                # Fallback: check tag name directly (for backwards compatibility)
                elif tag_name and tag_name[0:1] in ("v", "V"):
                    has_prefix = "true"
            except Exception as e:
                print(f"Warning: Could not parse JSON output, using defaults: {e}", file=sys.stderr)

        # Write to GITHUB_OUTPUT in single block
        with open(os.environ["GITHUB_OUTPUT"], "a") as f:
            f.write(f"valid={success}\n")
            f.write(f"tag_type={version_type}\n")
            f.write(f"signing_type={signature_type}\n")
            f.write(f"development_tag={is_dev}\n")
            f.write(f"version_prefix={has_prefix}\n")
            f.write(f"tag_name={tag_name}\n")
            f.write(f"artifact_path={artifact_dir}\n")
            f.write(f"artifact_suffix={artifact_suffix}\n")

        # Exit with the original command's exit code
        sys.exit(exit_code)
        PYEOF

        # Execute the Python script with JSON output and exit code as arguments
        python /tmp/parse_output.py "${JSON_OUTPUT:-}" "${EXIT_CODE}" "${ARTIFACT_DIR:-}" "${ARTIFACT_SUFFIX:-}"

        # Exit code is already set by Python script above
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
        GITHUB_SERVER_URL: ${{ inputs.github_server_url || env.GITHUB_SERVER_URL || 'https://github.com' }}
        GERRIT_USERNAME: ${{ inputs.gerrit_username }}
        GERRIT_PASSWORD: ${{ inputs.gerrit_password }}

    - name: 'Upload JSON artifact'
      if: always() && inputs.upload_json == 'true' && steps.validate.outputs.artifact_path != ''
      # yamllint disable-line rule:line-length
      uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
      with:
        # yamllint disable-line rule:line-length
        name: tag-validation-${{ steps.validate.outputs.artifact_suffix }}
        path: ${{ steps.validate.outputs.artifact_path }}/
        if-no-files-found: warn
        retention-days: 90
