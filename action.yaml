---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

# tag-validate-action
name: 'ðŸ·ï¸ Unified Tag Validation'
description: >-
  Validates tags for versioning compliance (SemVer/CalVer) and cryptographic
  signatures (SSH/GPG)

inputs:
  tag_location:
    description: >-
      Path to tag - supports two formats:
      1. Remote: ORG/REPO/TAG
      (e.g., lfreleng-actions/tag-validate-action/v0.1.0)
      2. Local: PATH/TO/REPO/TAG (e.g., ./my-repo/v1.0.0)
      Local paths must contain a .git directory
    required: false
    default: ''
  tag_string:
    description: >-
      Tag string to validate (version format only, no signature check)
    required: false
    default: ''
  require_type:
    description: >-
      Required tag type: semver, calver, both, none (comma-separated for
      multiple). When omitted or set to 'none', any format is accepted
      (including customtags). Examples: 'semver', 'semver,calver', 'none'.
    required: false
    default: ''
  require_signed:
    description: >-
      Signature requirement (comma-separated for multiple, e.g., 'gpg,ssh'):
      - gpg: Require verified GPG signature
      - ssh: Require verified SSH signature
      - gpg-unverifiable: Accept GPG signature without verification
      - unsigned: Must be unsigned
      Omit for no signature requirement.
    required: false
    default: ''
  require_github:
    description: >-
      Requires that the signing key is registered to a GitHub account.
      Requires a GitHub token.
    required: false
    default: 'false'
  require_owner:
    description: >-
      GitHub username(s) or email address(es) that must own the signing key
      (comma or space-separated for multiple, e.g., 'octocat,monalisa' or
      'user@example.com').
      Requires a GitHub token. When specified, require_github is implied.
    required: false
    default: ''
  reject_development:
    description: >-
      Reject development/pre-release tags (tags containing alpha, beta, rc, dev,
      pre, snapshot, nightly, canary, or preview). When enabled, validation will
      fail for any tag identified as a development version.
    required: false
    default: 'false'
  permit_missing:
    description: 'Allow missing tags without error'
    required: false
    default: 'false'
  token:
    description: >-
      GitHub token for authenticated API calls and private repository access
    required: false
    default: ''
  github_server_url:
    description: >-
      GitHub server URL for git operations (supports GitHub Enterprise Server).
      If not provided, falls back to GITHUB_SERVER_URL environment variable or
      https://github.com
    required: false
    default: ''
  debug:
    description: >-
      Enable debug output in action logs. This enables both bash command
      tracing (set -x) and Python verbose logging (--verbose flag), providing
      comprehensive debugging information including git operations, API calls,
      and internal validation steps.
    required: false
    default: 'false'
  use_local_action:
    description: >-
      Use local repository action/code instead of the PyPI package.
      Set to 'true' when testing changes in a fork or branch before merging.
    required: false
    default: 'false'

outputs:
  valid:
    description: 'Set true if tag passes validation checks'
    value: ${{ steps.validate.outputs.valid }}
  tag_type:
    description: 'Detected tag type (semver|calver|both|other|unknown)'
    value: ${{ steps.validate.outputs.tag_type }}
  signing_type:
    # yamllint disable rule:line-length
    description: 'Detected signing type (gpg|ssh|unsigned|lightweight|invalid|gpg-unverifiable)'
    value: ${{ steps.validate.outputs.signing_type }}
  development_tag:
    description: 'Set true if development/pre-release tag detected'
    value: ${{ steps.validate.outputs.development_tag }}
  version_prefix:
    description: 'Set true if tag has version prefix (v or V)'
    value: ${{ steps.validate.outputs.version_prefix }}
  tag_name:
    description: 'The tag name being validated'
    value: ${{ steps.validate.outputs.tag_name }}

runs:
  using: 'composite'
  steps:
    # yamllint disable rule:line-length
    - name: 'Set up Python'
      uses: actions/setup-python@a309ff8b426b58ec0e2a45f0f869d46889d02405 # v6.2.0
      with:
        python-version: '3.12'

    - name: 'Install uv'
      if: inputs.use_local_action != 'true' && !contains(github.repository, 'lfreleng-actions/tag-validate-action')
      uses: astral-sh/setup-uv@61cb8a9741eeb8a550a1b8544337180c0fc8476b # v7.2.0

    - name: 'Install local dependencies'
      if: inputs.use_local_action == 'true' || contains(github.repository, 'lfreleng-actions/tag-validate-action')
      shell: bash
      run: |
        # Install dependencies without the package itself to avoid setuptools-scm issues
        pip install dependamerge>=0.1.19 aiolimiter>=1.2.1 "httpx[http2]>=0.28.1" pydantic>=2.12.5 rich>=14.2.0 typer>=0.21.1 python-gnupg>=0.5.3 cryptography>=46.0.3 packaging>=24.2
        # Add the source directory to PYTHONPATH for direct module access
        echo "PYTHONPATH=${{ github.action_path }}/src:${PYTHONPATH:-}" >> "$GITHUB_ENV"

    - name: 'Fetch tag objects'
      shell: bash
      run: |
        # Ensure we have the actual tag object, not just the ref
        # This is necessary because checkout might only fetch tag refs, not tag objects
        if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
          TAG_NAME="${GITHUB_REF_NAME:-}"
          echo "Fetching tag object for: ${TAG_NAME}"
          git fetch origin "refs/tags/${TAG_NAME}:refs/tags/${TAG_NAME}" --force || true
          TAG_TYPE=$(git cat-file -t "${TAG_NAME}" 2>/dev/null || echo "unknown")
          echo "Tag object type: ${TAG_TYPE}"
        fi

    - name: 'Validate tag'
      id: validate
      shell: bash
      run: |
        # Run tag-validate Python CLI with JSON output
        set -euo pipefail

        # Normalize inputs to lowercase for case-insensitive matching
        REQUIRE_TYPE=$(echo "${{ inputs.require_type }}" | tr '[:upper:]' '[:lower:]' | tr -d ' ')
        REQUIRE_SIGNED=$(echo "${{ inputs.require_signed }}" | tr '[:upper:]' '[:lower:]' | tr -d ' ')
        REQUIRE_GITHUB=$(echo "${{ inputs.require_github }}" | tr '[:upper:]' '[:lower:]')
        REQUIRE_OWNER="${{ inputs.require_owner }}"
        REJECT_DEVELOPMENT=$(echo "${{ inputs.reject_development }}" | tr '[:upper:]' '[:lower:]')
        PERMIT_MISSING=$(echo "${{ inputs.permit_missing }}" | tr '[:upper:]' '[:lower:]')
        DEBUG=$(echo "${{ inputs.debug }}" | tr '[:upper:]' '[:lower:]')

        # Build command arguments
        ARGS=("--json")
        USE_VERSION_ONLY="false"

        # Determine tag location or string
        if [ -n "${{ inputs.tag_location }}" ]; then
          TAG_LOCATION="${{ inputs.tag_location }}"
          # Python CLI now handles format normalization (owner/repo/tag â†’ owner/repo@tag)
        elif [ -n "${{ inputs.tag_string }}" ]; then
          # For tag_string, use validate-version command
          USE_VERSION_ONLY="true"
          TAG_LOCATION="${{ inputs.tag_string }}"
        elif [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
          # Auto-detect from tag push event
          TAG_LOCATION="${GITHUB_REF_NAME:-}"
          echo "ðŸ·ï¸ Tag push event detected: ${TAG_LOCATION}"
        elif [ "${PERMIT_MISSING}" = "true" ]; then
          # Handle missing tag with permit_missing=true
          echo "â„¹ï¸ No tag found, but permit_missing=true"
          # Write minimal outputs and exit successfully
          cat >> "${GITHUB_OUTPUT}" << 'EOFOUTPUT'
        valid=true
        tag_type=unknown
        signing_type=unsigned
        development_tag=false
        version_prefix=false
        tag_name=
        EOFOUTPUT
          exit 0
        else
          echo "Error: Either tag_location or tag_string must be provided" >&2
          exit 1
        fi

        # Add validation options
        # Common args for both validate and verify commands
        COMMON_ARGS=()

        # Add --require-type if it's not empty (supports comma-separated values)
        if [ -n "${REQUIRE_TYPE}" ]; then
          COMMON_ARGS+=("--require-type" "${REQUIRE_TYPE}")
        fi

        # Signature-specific args only for verify command
        VERIFY_ARGS=()

        # Add --require-signed if it's not empty (supports comma-separated values)
        # Values: gpg, ssh, gpg-unverifiable, unsigned (or comma-separated combinations)
        # Handle backward compatibility for boolean values
        if [ -n "${REQUIRE_SIGNED}" ]; then
          # Convert boolean values for backward compatibility
          case "${REQUIRE_SIGNED}" in
            "true")
              # For backward compatibility: true means require any valid signature
              VERIFY_ARGS+=("--require-signed" "gpg,ssh")
              ;;
            "false")
              # For backward compatibility: false means accept unsigned
              VERIFY_ARGS+=("--require-signed" "unsigned")
              ;;
            *)
              # Pass through specific signature types as-is
              VERIFY_ARGS+=("--require-signed" "${REQUIRE_SIGNED}")
              ;;
          esac
        fi

        # Add GitHub key verification if requested
        if [ "${REQUIRE_GITHUB}" = "true" ]; then
          VERIFY_ARGS+=("--require-github")
        fi

        # Add require-owner if provided (comma or space separated values)
        if [ -n "${REQUIRE_OWNER}" ]; then
          VERIFY_ARGS+=("--require-owner" "${REQUIRE_OWNER}")
        fi

        # Add reject-development flag if enabled (only for verify command)
        if [ "${REJECT_DEVELOPMENT}" = "true" ]; then
          VERIFY_ARGS+=("--reject-development")
        fi

        # Add permit_missing flag if enabled (applies to both)
        if [ "${PERMIT_MISSING}" = "true" ]; then
          COMMON_ARGS+=("--permit-missing")
        fi

        # GitHub token is passed via GITHUB_TOKEN environment variable (see env section below)
        # This is more secure than passing it as a CLI argument

        # Enable debug output
        if [ "${DEBUG}" = "true" ]; then
          set -x
        fi

        # Determine which CLI invocation method to use
        if [[ "${{ inputs.use_local_action }}" == "true" ]] || \
           [[ "${{ github.repository }}" =~ lfreleng-actions/tag-validate-action ]]; then
          CLI_CMD="python -m tag_validate.cli"
          echo "Using local action code: ${CLI_CMD}"
        else
          # Use PyPI package via uvx
          # The --quiet flag is critical to suppress uvx's download progress output,
          # which would otherwise mix with the JSON output from tag-validate and cause parsing errors
          CLI_CMD="uvx --quiet --from tag-validate tag-validate"
          echo "Using PyPI package via uvx"
        fi

        # Execute validation and capture output
        # Display exact command being executed for debugging
        # Note: This is safe to log because sensitive data (GITHUB_TOKEN) is passed via
        # environment variable (see env section below), NOT as a CLI argument
        EXIT_CODE=0
        # Add --verbose flag when debug is enabled for comprehensive Python logging
        VERBOSE_FLAG=""
        if [ "${DEBUG}" = "true" ]; then
          VERBOSE_FLAG="--verbose"
        fi

        if [ "${USE_VERSION_ONLY}" = "true" ]; then
          # validate command only uses common args (no signature args)
          echo "ðŸ” Executing: ${CLI_CMD} ${VERBOSE_FLAG} validate \"${TAG_LOCATION}\" ${COMMON_ARGS[@]} --json"
          JSON_OUTPUT=$(${CLI_CMD} ${VERBOSE_FLAG} validate "${TAG_LOCATION}" "${COMMON_ARGS[@]}" --json 2>&1) || EXIT_CODE=$?
        else
          # verify command uses both common and verify-specific args
          ALL_VERIFY_ARGS=("${COMMON_ARGS[@]}" "${VERIFY_ARGS[@]}")
          echo "ðŸ” Executing: ${CLI_CMD} ${VERBOSE_FLAG} verify \"${TAG_LOCATION}\" ${ALL_VERIFY_ARGS[@]} --json"
          JSON_OUTPUT=$(${CLI_CMD} ${VERBOSE_FLAG} verify "${TAG_LOCATION}" "${ALL_VERIFY_ARGS[@]}" --json 2>&1) || EXIT_CODE=$?
        fi

        # Extract and validate JSON from output using Python
        # This handles cases where uvx might include non-JSON output
        # Python is already available from the setup-python step above
        cat > /tmp/extract_json.py << 'EOF'
        import json
        import sys

        # Read raw output from stdin
        text = sys.stdin.read()

        # Try to find the first valid JSON object in the output
        decoder = json.JSONDecoder()
        start = text.find('{')
        max_attempts = 10  # Prevent infinite loops in malformed data
        attempts = 0
        while start != -1 and attempts < max_attempts:
            attempts += 1
            try:
                # Parse the JSON starting at this position without slicing
                obj, _ = decoder.raw_decode(text, idx=start)
                # Re-serialize to ensure we have clean, valid JSON only
                clean_json = json.dumps(obj, ensure_ascii=False)
                print(clean_json, end='')
                sys.exit(0)
            except (json.JSONDecodeError, ValueError):
                # Not valid JSON at this position, search for the next candidate
                start = text.find('{', start + 1)

        # No valid JSON found
        print('ERROR: No valid JSON object found in output', file=sys.stderr)
        sys.exit(1)
        EOF

        EXTRACTED_JSON=$(echo "${JSON_OUTPUT}" | python3 /tmp/extract_json.py)
        EXTRACT_EXIT_CODE=$?

        if [ ${EXTRACT_EXIT_CODE} -ne 0 ]; then
          echo "Error: Failed to extract valid JSON from tag-validate CLI output" >&2
          echo "Raw output was:" >&2
          echo "${JSON_OUTPUT}" >&2
          exit 1
        fi

        # Display the extracted JSON
        echo "${EXTRACTED_JSON}"

        # Use the extracted JSON for further processing
        JSON_OUTPUT="${EXTRACTED_JSON}"

        # Python CLI now handles permit_missing logic internally
        # If exit code is 0, validation succeeded (or was permitted to pass)
        # If exit code is non-zero, validation failed

        # Parse JSON output using Python (bundled with actions/setup-python)
        # Create temporary Python script to avoid YAML parsing issues
        cat > /tmp/parse_output.py << 'PYEOF'
        import json
        import sys
        import os
        import re

        json_output = sys.argv[1]

        try:
            data = json.loads(json_output)
            success = str(data.get("success", False)).lower()
            tag_name = data.get("tag_name", data.get("version", ""))
            version_type = data.get("version_type", data.get("detected_type", "unknown")) or "unknown"
            # Map 'other' to 'other' (custom format), keep all other values as-is
            if version_type not in ["semver", "calver", "both", "other"]:
                version_type = "unknown"
            signature_type = data.get("signature_type", "unsigned") or "unsigned"

            # Determine development tag
            # Support both new (development_tag) and old (is_development) field names for backwards compatibility
            is_dev = "false"
            if data.get("development_tag", False) or data.get("is_development", False):
                is_dev = "true"
            # Fallback: check tag name for development indicators (for backwards compatibility)
            elif tag_name and re.search(r"(dev|pre|alpha|beta|rc|snapshot|nightly|canary|preview)", tag_name.lower()):
                is_dev = "true"

            # Determine version prefix
            # Support both new (version_prefix) and old (has_prefix) field names for backwards compatibility
            has_prefix = "false"
            if data.get("version_prefix", False) or data.get("has_prefix", False):
                has_prefix = "true"
            # Fallback: check tag name directly (for backwards compatibility)
            elif tag_name and tag_name[0:1] in ("v", "V"):
                has_prefix = "true"

            # Write to GITHUB_OUTPUT in single block
            with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                f.write(f"valid={success}\n")
                f.write(f"tag_type={version_type}\n")
                f.write(f"signing_type={signature_type}\n")
                f.write(f"development_tag={is_dev}\n")
                f.write(f"version_prefix={has_prefix}\n")
                f.write(f"tag_name={tag_name}\n")

            # Exit with appropriate code
            sys.exit(0 if success == "true" else 1)

        except Exception as e:
            print(f"Error parsing JSON output: {e}", file=sys.stderr)
            print(f"JSON output was: {json_output}", file=sys.stderr)
            sys.exit(1)
        PYEOF

        # Execute the Python script with JSON output as argument
        python /tmp/parse_output.py "${JSON_OUTPUT}"

        # Exit code is already set by Python script above
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
        GITHUB_SERVER_URL: ${{ inputs.github_server_url || env.GITHUB_SERVER_URL || 'https://github.com' }}
