---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

# tag-validate-action
name: 'ðŸ·ï¸ Unified Tag Validation'
description: >-
  Validates tags for versioning compliance (SemVer/CalVer) and cryptographic
  signatures (SSH/GPG)

inputs:
  tag_location:
    description: >-
      Path to tag - supports two formats:
      1. Remote: ORG/REPO/TAG
      (e.g., lfreleng-actions/tag-validate-action/v0.1.0)
      2. Local: PATH/TO/REPO/TAG (e.g., ./my-repo/v1.0.0)
      Local paths must contain a .git directory
    required: false
    default: ''
  tag_string:
    description: >-
      Tag string to validate (version format only, no signature check)
    required: false
    default: ''
  require_type:
    description: 'Required tag type (semver|calver|none)'
    required: false
    default: 'none'
  require_signed:
    description: 'Signature requirement (true|ssh|gpg|false|ambivalent)'
    required: false
    default: 'ambivalent'
  permit_missing:
    description: 'Allow missing tags without error'
    required: false
    default: 'false'
  token:
    description: >-
      GitHub token for authenticated API calls and private repository access
    required: false
    default: ''

outputs:
  valid:
    description: 'Set true if tag passes validation checks'
    value: ${{ steps.validate.outputs.valid }}
  tag_type:
    description: 'Detected tag type (semver|calver|both|unknown)'
    value: ${{ steps.validate.outputs.tag_type }}
  signing_type:
    description: 'Type of signing used (unsigned|ssh|gpg)'
    value: ${{ steps.validate.outputs.signing_type }}
  development_tag:
    description: 'Set true if tag contains pre-release/development strings'
    value: ${{ steps.validate.outputs.development_tag }}
  version_prefix:
    description: 'Set true if tag has leading v/V character'
    value: ${{ steps.validate.outputs.version_prefix }}
  tag_name:
    description: 'The tag name being validated'
    value: ${{ steps.validate.outputs.tag_name }}

runs:
  using: 'composite'
  steps:
    - name: 'Validate tag'
      id: validate
      shell: bash
      # yamllint disable rule:line-length
      run: |
        # Validate tag
        set -e

        # Initialize variables
        tag_location="${{ inputs.tag_location }}"
        tag_string="${{ inputs.tag_string }}"
        require_type=$(echo "${{ inputs.require_type }}" | tr '[:upper:]' '[:lower:]')
        require_signed=$(echo "${{ inputs.require_signed }}" | tr '[:upper:]' '[:lower:]')
        permit_missing="${{ inputs.permit_missing }}"
        token="${{ inputs.token }}"

        tag_name=""
        tag_type="unknown"
        signing_type="unsigned"
        development_tag="false"
        version_prefix="false"
        valid="true"
        is_remote_tag="false"
        repo_org=""
        repo_name=""
        remote_tag=""

        # ==================================================================
        # STEP 1: Determine tag source and extract tag name
        # ==================================================================

        if [ -n "$tag_location" ]; then
          echo "ðŸ“ Tag location provided: $tag_location"

          # Determine if this is a local path or remote reference
          # Local paths start with ./ or / or contain a .git directory
          local_repo_path=""

          # Extract the last component as the potential tag name
          potential_tag=$(echo "$tag_location" | rev | cut -d'/' -f1 | rev)
          potential_repo_path=$(echo "$tag_location" | rev | cut -d'/' -f2- | rev)

          # Check if this looks like a local path
          if [[ "$tag_location" == ./* ]] || [[ "$tag_location" == /* ]] || [ -d "$potential_repo_path/.git" ]; then
            echo "ðŸ  Detected local repository path"

            # Validate that the repository path exists and contains .git
            if [ ! -d "$potential_repo_path/.git" ]; then
              echo "Error: Local path does not contain a Git repository (.git directory not found) âŒ"
              echo "Path checked: $potential_repo_path"
              exit 1
            fi

            local_repo_path="$potential_repo_path"
            tag_name="$potential_tag"
            is_remote_tag="false"

            echo "  Repository path: $local_repo_path"
            echo "  Tag: $tag_name"

            # Change to the repository directory for git operations
            cd "$local_repo_path"

            # Verify the tag exists
            echo "Checking for tag '$tag_name' in local repository..."
            if ! git tag -l "$tag_name" | grep -q "^$tag_name$"; then
              echo "Available tags:"
              git tag -l | head -20

              if [ "$permit_missing" = "true" ]; then
                echo "âš ï¸  Tag not found in local repository, but permit_missing=true"
                echo "valid=true" >> "$GITHUB_OUTPUT"
                echo "tag_type=unknown" >> "$GITHUB_OUTPUT"
                echo "signing_type=unsigned" >> "$GITHUB_OUTPUT"
                echo "development_tag=false" >> "$GITHUB_OUTPUT"
                echo "version_prefix=false" >> "$GITHUB_OUTPUT"
                echo "tag_name=$tag_name" >> "$GITHUB_OUTPUT"
                exit 0
              else
                echo "Error: Tag '$tag_name' not found in local repository âŒ"
                exit 1
              fi
            fi
            echo "âœ“ Tag found in local repository"

          else
            # Remote reference format: ORG/REPO/TAG
            echo "ðŸŒ Detected remote repository reference"
            is_remote_tag="true"

            # Parse tag_location: ORG/REPO/TAG
            if [[ ! "$tag_location" =~ ^[^/]+/[^/]+/.+ ]]; then
              echo "Error: Invalid tag_location format âŒ"
              echo "Expected formats:"
              echo "  - Remote: ORG/REPO/TAG (e.g., lfreleng-actions/tag-validate-action/v0.1.0)"
              echo "  - Local: PATH/TO/REPO/TAG (e.g., ./my-repo/v1.0.0)"
              exit 1
            fi

            # Extract components
            repo_org=$(echo "$tag_location" | cut -d'/' -f1)
            repo_name=$(echo "$tag_location" | cut -d'/' -f2)
            remote_tag=$(echo "$tag_location" | cut -d'/' -f3-)

            echo "  Organization: $repo_org"
            echo "  Repository: $repo_name"
            echo "  Tag: $remote_tag"

            tag_name="$remote_tag"
          fi

        elif [ -n "$tag_string" ]; then
          echo "ðŸ“ Tag string provided: $tag_string"
          tag_name="$tag_string"

        else
          # Check if triggered by tag push event
          if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
            tag_name="${GITHUB_REF_NAME:-}"
            echo "ðŸ·ï¸  Tag push event detected: $tag_name"

            # Verify we're in a git repository
            if ! git rev-parse --git-dir > /dev/null 2>&1; then
              echo "Warning: Not in a git repository, cannot check signatures"
            fi
          else
            # No tag source provided
            if [ "$permit_missing" = "true" ]; then
              echo "â„¹ï¸  No tag found, but permit_missing=true"
              echo "valid=true" >> "$GITHUB_OUTPUT"
              echo "tag_type=unknown" >> "$GITHUB_OUTPUT"
              echo "signing_type=unsigned" >> "$GITHUB_OUTPUT"
              echo "development_tag=false" >> "$GITHUB_OUTPUT"
              echo "version_prefix=false" >> "$GITHUB_OUTPUT"
              echo "tag_name=" >> "$GITHUB_OUTPUT"
              exit 0
            else
              echo "Error: No tag found (not a tag push event, no tag_location, no tag_string) âŒ"
              exit 1
            fi
          fi
        fi

        # ==================================================================
        # STEP 2: Fetch remote tag if needed
        # ==================================================================

        if [ "$is_remote_tag" = "true" ]; then
          echo ""
          echo "ðŸŒ Fetching remote tag from GitHub..."

          # Try original tag name first
          tag_exists="false"
          tag_to_fetch="$remote_tag"

          # Prepare curl headers for authenticated requests
          curl_headers=()
          if [ -n "$token" ]; then
            curl_headers=("-H" "Authorization: token $token")
          fi

          # Check if tag exists using GitHub API
          if [ ${#curl_headers[@]} -eq 0 ]; then
            http_code=$(curl -s -o /dev/null -w "%{http_code}" \
              "https://api.github.com/repos/$repo_org/$repo_name/git/refs/tags/$remote_tag")
          else
            http_code=$(curl -s -o /dev/null -w "%{http_code}" \
              "${curl_headers[@]}" \
              "https://api.github.com/repos/$repo_org/$repo_name/git/refs/tags/$remote_tag")
          fi

          if [ "$http_code" = "200" ]; then
            tag_exists="true"
            echo "âœ“ Tag found: $remote_tag"
          else
            # Try stripping/adding 'v' prefix
            if [[ "$remote_tag" == v* ]] || [[ "$remote_tag" == V* ]]; then
              # Try without 'v' prefix
              alt_tag="${remote_tag:1}"
              if [ ${#curl_headers[@]} -eq 0 ]; then
                http_code=$(curl -s -o /dev/null -w "%{http_code}" \
                  "https://api.github.com/repos/$repo_org/$repo_name/git/refs/tags/$alt_tag")
              else
                http_code=$(curl -s -o /dev/null -w "%{http_code}" \
                  "${curl_headers[@]}" \
                  "https://api.github.com/repos/$repo_org/$repo_name/git/refs/tags/$alt_tag")
              fi

              if [ "$http_code" = "200" ]; then
                tag_exists="true"
                tag_to_fetch="$alt_tag"
                tag_name="$alt_tag"
                echo "âœ“ Tag found (without v prefix): $alt_tag"
              fi
            else
              # Try with 'v' prefix
              alt_tag="v$remote_tag"
              if [ ${#curl_headers[@]} -eq 0 ]; then
                http_code=$(curl -s -o /dev/null -w "%{http_code}" \
                  "https://api.github.com/repos/$repo_org/$repo_name/git/refs/tags/$alt_tag")
              else
                http_code=$(curl -s -o /dev/null -w "%{http_code}" \
                  "${curl_headers[@]}" \
                  "https://api.github.com/repos/$repo_org/$repo_name/git/refs/tags/$alt_tag")
              fi

              if [ "$http_code" = "200" ]; then
                tag_exists="true"
                tag_to_fetch="$alt_tag"
                tag_name="$alt_tag"
                echo "âœ“ Tag found (with v prefix): $alt_tag"
              fi
            fi
          fi

          if [ "$tag_exists" = "false" ]; then
            if [ "$permit_missing" = "true" ]; then
              echo "âš ï¸  Remote tag not found, but permit_missing=true"
              echo "valid=true" >> "$GITHUB_OUTPUT"
              echo "tag_type=unknown" >> "$GITHUB_OUTPUT"
              echo "signing_type=unsigned" >> "$GITHUB_OUTPUT"
              echo "development_tag=false" >> "$GITHUB_OUTPUT"
              echo "version_prefix=false" >> "$GITHUB_OUTPUT"
              echo "tag_name=$remote_tag" >> "$GITHUB_OUTPUT"
              exit 0
            else
              echo "Error: Remote tag not found: $repo_org/$repo_name/$remote_tag âŒ"
              exit 1
            fi
          fi

          # Clone repository with tags
          echo "Cloning repository to check tag signature..."
          temp_dir=$(mktemp -d)
          trap 'rm -rf "$temp_dir"' EXIT

          # Prepare clone URL with token if provided
          clone_url="https://github.com/$repo_org/$repo_name.git"
          if [ -n "$token" ]; then
            clone_url="https://x-access-token:$token@github.com/$repo_org/$repo_name.git"
          fi

          git clone --depth 1 --branch "$tag_to_fetch" \
            "$clone_url" "$temp_dir" 2>&1 || {
            echo "Warning: Could not clone repository, signature check will be skipped"
          }

          if [ -d "$temp_dir/.git" ]; then
            cd "$temp_dir"
            git fetch --tags 2>/dev/null || true
          fi
        fi

        # ==================================================================
        # STEP 3: Check for version prefix
        # ==================================================================

        if [[ "$tag_name" == v* ]] || [[ "$tag_name" == V* ]]; then
          version_prefix="true"
          echo "âœ“ Version prefix detected: ${tag_name:0:1}"
        fi

        # Strip leading 'v' or 'V' for validation
        clean_tag="$tag_name"
        if [[ "$tag_name" == v* ]] || [[ "$tag_name" == V* ]]; then
          clean_tag="${tag_name:1}"
        fi

        # ==================================================================
        # STEP 4: Check for development version
        # ==================================================================

        if echo "$clean_tag" | grep -Eqi '(dev|pre|alpha|beta|rc|snapshot|nightly|canary|preview)'; then
          development_tag="true"
          echo "âœ“ Development/pre-release tag detected"
        fi

        # ==================================================================
        # STEP 5: Determine tag type (SemVer or CalVer)
        # ==================================================================

        # SemVer pattern (from official semver.org)
        semver_pattern="^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$"

        # CalVer pattern (flexible, supports common formats)
        # Breakdown:
        #   ^(\d{2}|\d{4})           - Year: 2 or 4 digits (e.g., 25 or 2025)
        #   \.(\d{1}|\d{2})          - Month: 1 or 2 digits (e.g., 1 or 01)
        #   ((\.|\_|-)[a-zA-Z][a-zA-Z0-9\.\-\_]*)? - Optional metadata at month level
        #                                            (e.g., -SNAPSHOT, .beta1)
        #                                            Must start with letter after separator
        #   (\.(\d{1}|\d{2})((\.|\_|-)[a-zA-Z][a-zA-Z0-9\.\-\_]*)?)? - Optional third segment
        #                                            Day/patch (1-2 digits) with optional metadata
        #                                            (e.g., .15, .0-alpha)
        # Examples: 2025.1, 2025.01.15, 25.1.0, 2025.1-SNAPSHOT, 2025.01.15-beta.1
        calver_pattern="^(\d{2}|\d{4})\.(\d{1}|\d{2})((\.|\_|-)[a-zA-Z][a-zA-Z0-9\.\-\_]*)?(\.(\d{1}|\d{2})((\.|\_|-)[a-zA-Z][a-zA-Z0-9\.\-\_]*)?)?$"

        # Check both patterns to determine tag type
        matches_semver=false
        matches_calver=false

        if echo "$clean_tag" | grep -Pq "$semver_pattern"; then
          matches_semver=true
        fi

        if echo "$clean_tag" | grep -Pq "$calver_pattern"; then
          matches_calver=true
        fi

        # Determine tag type based on what matched
        if [ "$matches_semver" = true ] && [ "$matches_calver" = true ]; then
          tag_type="both"
          echo "âœ“ Tag matches both Semantic Versioning (SemVer) and Calendar Versioning (CalVer)"
        elif [ "$matches_calver" = true ]; then
          tag_type="calver"
          echo "âœ“ Tag matches Calendar Versioning (CalVer)"
        elif [ "$matches_semver" = true ]; then
          tag_type="semver"
          echo "âœ“ Tag matches Semantic Versioning (SemVer)"
        else
          tag_type="unknown"
          echo "âš ï¸  Tag does not match SemVer or CalVer patterns"
        fi

        # ==================================================================
        # STEP 6: Validate required type
        # ==================================================================

        if [ "$require_type" != "none" ]; then
          # Check if tag type matches requirement
          # "both" type satisfies either semver or calver requirement
          if [ "$tag_type" = "$require_type" ]; then
            echo "âœ“ Tag type matches requirement: $require_type"
          elif [ "$tag_type" = "both" ] && { [ "$require_type" = "semver" ] || [ "$require_type" = "calver" ]; }; then
            echo "âœ“ Tag matches both SemVer and CalVer (satisfies $require_type requirement)"
          else
            echo "Error: Tag type mismatch âŒ"
            echo "  Required: $require_type"
            echo "  Detected: $tag_type"
            valid="false"
            exit 1
          fi
        fi

        # ==================================================================
        # STEP 7: Check tag signature (only if not tag_string)
        # ==================================================================

        if [ -z "$tag_string" ]; then
          # We can check signatures (either local repo or fetched remote)
          if git rev-parse --git-dir > /dev/null 2>&1; then
            # Check if tag exists in repo
            if git rev-parse "$tag_name" > /dev/null 2>&1; then
              echo ""
              echo "ðŸ” Checking tag signature..."

              # Get tag verification output
              verify_output=$(git verify-tag --raw "$tag_name" 2>&1 || true)

              # Check for GPG signature
              if echo "$verify_output" | grep -qE "\[GNUPG:\] (GOODSIG|VALIDSIG|ERRSIG)"; then
                signing_type="gpg"
                echo "âœ“ Tag is signed with GPG key ðŸ”‘"
              # Check for SSH signature (Git 2.34+)
              elif echo "$verify_output" | grep -qi "Good \"git\" signature.*with.*key"; then
                signing_type="ssh"
                echo "âœ“ Tag is signed with SSH key ðŸ”‘"
              # Alternative SSH detection via tag object
              elif git cat-file tag "$tag_name" 2>/dev/null | grep -q "^-----BEGIN SSH SIGNATURE-----"; then
                signing_type="ssh"
                echo "âœ“ Tag is signed with SSH key ðŸ”‘"
              else
                signing_type="unsigned"
                echo "â„¹ï¸  Tag is not signed"
              fi
            else
              echo "âš ï¸  Tag not found in repository, cannot verify signature"
              signing_type="unsigned"
            fi
          else
            echo "âš ï¸  Not in a git repository, cannot verify signature"
            signing_type="unsigned"
          fi
        else
          # tag_string mode - cannot check signatures
          signing_type="unsigned"
          echo "â„¹ï¸  String validation mode - signature check skipped"
        fi

        # ==================================================================
        # STEP 8: Validate signature requirements
        # ==================================================================

        if [ "$require_signed" != "ambivalent" ]; then
          echo ""
          echo "ðŸ”’ Validating signature requirements..."

          case "$require_signed" in
            true)
              if [ "$signing_type" = "unsigned" ]; then
                echo "Error: Tag was NOT signed âŒ"
                valid="false"
                exit 1
              else
                echo "âœ“ Tag was signed âœ…"
              fi
              ;;
            ssh)
              if [ "$signing_type" = "gpg" ]; then
                echo "Error: Tag was signed with GPG key (SSH required) âŒ"
                valid="false"
                exit 1
              elif [ "$signing_type" = "unsigned" ]; then
                echo "Error: Tag was NOT signed (SSH required) âŒ"
                valid="false"
                exit 1
              else
                echo "âœ“ Tag was signed with SSH key âœ…"
              fi
              ;;
            gpg)
              if [ "$signing_type" = "ssh" ]; then
                echo "Error: Tag was signed with SSH key (GPG required) âŒ"
                valid="false"
                exit 1
              elif [ "$signing_type" = "unsigned" ]; then
                echo "Error: Tag was NOT signed (GPG required) âŒ"
                valid="false"
                exit 1
              else
                echo "âœ“ Tag was signed with GPG key âœ…"
              fi
              ;;
            false)
              if [ "$signing_type" != "unsigned" ]; then
                echo "Error: Tag was signed (unsigned required) âŒ"
                valid="false"
                exit 1
              else
                echo "âœ“ Tag was unsigned âœ…"
              fi
              ;;
            *)
              echo "Warning: Unknown require_signed value: $require_signed"
              ;;
          esac
        fi

        # ==================================================================
        # STEP 9: Set outputs
        # ==================================================================

        echo ""
        echo "ðŸ“Š Validation Results:"
        echo "  Tag Name: $tag_name"
        echo "  Tag Type: $tag_type"
        echo "  Signing Type: $signing_type"
        echo "  Development Tag: $development_tag"
        echo "  Version Prefix: $version_prefix"
        echo "  Valid: $valid"

        echo "valid=$valid" >> "$GITHUB_OUTPUT"
        echo "tag_type=$tag_type" >> "$GITHUB_OUTPUT"
        echo "signing_type=$signing_type" >> "$GITHUB_OUTPUT"
        echo "development_tag=$development_tag" >> "$GITHUB_OUTPUT"
        echo "version_prefix=$version_prefix" >> "$GITHUB_OUTPUT"
        echo "tag_name=$tag_name" >> "$GITHUB_OUTPUT"

        echo "" >> "$GITHUB_STEP_SUMMARY"
        echo "## ðŸ·ï¸ Tag Validation Results" >> "$GITHUB_STEP_SUMMARY"
        echo "" >> "$GITHUB_STEP_SUMMARY"
        echo "| Property | Value |" >> "$GITHUB_STEP_SUMMARY"
        echo "|----------|-------|" >> "$GITHUB_STEP_SUMMARY"
        echo "| Tag Name | \`$tag_name\` |" >> "$GITHUB_STEP_SUMMARY"
        echo "| Tag Type | \`$tag_type\` |" >> "$GITHUB_STEP_SUMMARY"
        echo "| Signing Type | \`$signing_type\` |" >> "$GITHUB_STEP_SUMMARY"
        echo "| Development Tag | \`$development_tag\` |" >> "$GITHUB_STEP_SUMMARY"
        echo "| Version Prefix | \`$version_prefix\` |" >> "$GITHUB_STEP_SUMMARY"
        echo "| Valid | \`$valid\` |" >> "$GITHUB_STEP_SUMMARY"

        if [ "$valid" = "true" ]; then
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "âœ… **Tag validation passed**" >> "$GITHUB_STEP_SUMMARY"
        else
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "âŒ **Tag validation failed**" >> "$GITHUB_STEP_SUMMARY"
        fi

        echo ""
        echo "âœ… Tag validation complete"
